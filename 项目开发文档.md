# 2026.2.14

## 分析项目业务

-   用户业务
    -   用户注册，登入，详情，查找
-   社交【好友，群】
    -   好友： 添加好友，好友列表
    -   群： 进群，退群，群列表
-   聊天：
    -   私聊，群聊，聊天几率，已读未读

项目架构

![image-20260214115303892](../../../PHOTOS/image-20260214115303892.png)

常用命令

````
ssh onychen@192.168.88.129

192.168.88.130

scp -r d:\code\go\easy-chat onychen@192.168.88.129:~/easy-chat

```
ssh onychen@192.168.88.129 "rm -rf ~/easy-chat"                         
scp -r d:\code\go\easy-chat onychen@192.168.88.129:~/easy-chat

ssh onychen@192.168.88.130 "rm -rf ~/easy-chat"    
scp -r d:\code\go\easy-chat onychen@192.168.88.130:~/easy-chat
```

```
docker login --username=onychen crpi-osk929019sdokpya.cn-guangzhou.personal.cr.aliyuncs.com
```


````

# 流程

## 1.分析业务

在用户模块中，主要是用户的基本信息为主，暂时项目中不涉及用户的其他信息，因此主要的功能则为，注册/登入/用户信息/用户查找为主的业务需求。

## 2.先创建好大致项目结构

```
- apps    应用目录，记录相关的服务信息
  - user
     - api
     - rpc
  - im
- deploy  项目部署相关的信息，如部署的时候一些程序的配置，sql或者dockerfile
- pkg     项目的公共工具目录
- docker-compose.yml
- Makefile  项目编译脚本程序

```

## 3.构建项目

### 根据业务的需求，初步构建user的rpc服务方法以及服务方法提供的信息数据

```proto
syntax = "proto3";

package user;

option go_package = "./user";

// model
message UserEntity {
  string  id = 1;                // 用户id
  string  avatar = 2;            // 用户头像
  string  nickname = 3;          // 昵称
  string  phone  = 4;            // 手机号码
  int32   status  = 5;           // 是否锁住
  int32   sex = 6;
}

// req 与 respo
message Request {
  string ping = 1;
}

message Response {
  string pong = 1;
}

message LoginReq {
  string  phone = 1;
  string  password = 2;
}

message LoginResp {
  string Token = 1;
  int64 expire = 2;
}

message RegisterReq{
  string  phone = 1;
  string  nickname = 2;
  string  password = 3;
  string  avatar = 4;
  int32   sex = 5;
}

message RegisterResp {
  string Token = 1;
  int64 expire = 2;
}

message GetUserInfoReq {
  string id = 1;
}

message GetUserInfoResp {
  UserEntity user = 1;
}

message FindUserReq {
  string name = 1;
  string phone = 2;
  repeated string ids = 3;
}

message FindUserResp {
  repeated UserEntity user = 1;
}

service User {
  rpc Ping(Request) returns (Response);
  rpc Login(LoginReq) returns (LoginResp);
  rpc Register(RegisterReq) returns (RegisterResp);
  rpc GetUserInfo(GetUserInfoReq) returns (GetUserInfoResp);
  rpc FindUser(FindUserReq) returns (FindUserResp);
}

```

如上就是初步构建的user.proto, 在proto中的编写时候，可以区分一下模型和请求与响应返回的数据结构，而请求与响应一般建议与方法名尽可能的同名基于rep/resp，这样可以有助于proto信息使结构更清晰。

目前项目结构

```
apps
	user
		rpc
			user.proto
		bin
			exec.sh
```

运行完

```
goctl rpc protoc ./user.proto --go_out=. --go-grpc_out=. --zrpc_out=.
```

项目结构如下

![image-20260215150330827](../../../PHOTOS/image-20260215150330827.png)

### 编写部署脚本及dockerfile

因在项目中我们实际开发完成后就会将项目放到生成或测试上运行，特别是在测试的时候，有时候在修复bug的过程中会频繁的部署，因此这个时候我们就可以提前编辑好相关的脚步，通过脚本完成对程序的部署工作。

>   首先编写user服务的dockerfile

内容实际就是之前在讲docker的内容是相似的，但是需要注意目录位置

如下是要构建的dockerfile:

作用 ：把编译好的 Go 程序和配置文件打包到一个轻量级的 Alpine 容器中（构建镜像）

>   /easy-chat/deploy/dockerfile/Dockerfile_user_rpc_dev

```docker
FROM alpine:3.18

# 添加时区处理
RUN echo -e "https://mirrors.aliyun.com/alpine/v3.15/main\nhttps://mirrors.aliyun.com/alpine/v3.15/community" > /etc/apk/repositories && \
    apk update &&\
    apk --no-cache add tzdata && \
    cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime && \
    echo "Asia/Shanghai" >  /etc/timezone
ENV TZ=Asia/Shanghai

ARG SERVER_NAME=user
ARG SERVER_TYPE=rpc

ENV RUN_BIN bin/${SERVER_NAME}-${SERVER_TYPE}
ENV RUN_CONF /${SERVER_NAME}/conf/${SERVER_NAME}.yaml

# 这个关键词的意思是复制的意思，可以将宿主机中的内容复制到容器中
# 命令 左边是宿主机的目录，右边是容器目录
RUN mkdir /$SERVER_NAME && mkdir /$SERVER_NAME/bin && mkdir /$SERVER_NAME/conf

# 复制编译后的二进制文件
COPY ./bin/$SERVER_NAME-$SERVER_TYPE /$SERVER_NAME/bin/

# 复制配置文件
COPY ./apps/$SERVER_NAME/$SERVER_TYPE/etc/dev/$SERVER_NAME.yaml /$SERVER_NAME/conf/

# 为二进制提供执行权限
RUN chmod +x /$SERVER_NAME/bin/$SERVER_NAME-$SERVER_TYPE

# 该命令指定容器会默认进入那个目录，如我们每次进入服务器的时候会自动进入root目录一样的作用
WORKDIR /$SERVER_NAME

# 这个命令可以让我们的docker容器在启动的时候就执行下面的命令
# 与CMD不同之处是，在docker run 后跟的命令不能替换它，它仍然会启动的时候执行
# ENTRYPOINT ["$RUN_BIN", "-f", "$RUN_CONF"] // 这种写法不支持对环境变量的解析，
#您正在使用ENTRYPOINT 的exec形式。与shell表单不同，exec表单不会调用命令shell。这意味着正常的外壳处理不会发生。例如，ENTRYPOINT [ "echo", "$HOME" ]
# 将不会在$ HOME上进行变量替换。如果要进行shell处理，则可以使用shell形式或直接执行shell，例如：ENTRYPOINT [ "sh", "-c", "echo $HOME" ]。
#当使用exec表单并直接执行shell时（例如在shell表单中），是由shell进行环境变量扩展，而不是docker。（来自Dockerfile参考）
#

ENTRYPOINT $RUN_BIN -f $RUN_CONF

```

回顾之前部署的方式

```
# 先将程序编译成二进制可执行的文件
$ GOOS=linux GOARCH=amd64 CGO_ENABLED=0 go build -o bin/user-rpc ./apps/user/rpc/user.go

# 然后根据二进制文件构建成镜像文件
$ docker build -t user-rpc -f ./dockerfile_rpc .

# 再修改构建的镜像标签
$ docker tag user-rpc registry.cn-hangzhou.aliyuncs.com/easy-chat/user-rpc-test:latest

# 然后推送到阿里云上
$ docker push registry.cn-hangzhou.aliyuncs.com/easy-chat/user-rpc-test:latest

# 在部署的时候拉取下来构建容器运行即可
```

其实每次开发完新功能都是这个流程，所以我们不妨一键化
这里用到makefile,当然如果你习惯shell也是可以实现的。

```
/easy-chat/deploy/mk/user-rpc.mk
```

```makefile
VERSION=latest

SERVER_NAME=user
SERVER_TYPE=rpc

# 测试环境配置
# docker的镜像发布地址
DOCKER_REPO_TEST=crpi-osk929019sdokpya.cn-guangzhou.personal.cr.aliyuncs.com/easy-ct/${SERVER_NAME}-${SERVER_TYPE}-dev
# 测试版本
VERSION_TEST=$(VERSION)
# 编译的程序名称
APP_NAME_TEST=easy-im-${SERVER_NAME}-${SERVER_TYPE}-test

# 测试下的编译文件
DOCKER_FILE_TEST=./deploy/dockerfile/Dockerfile_${SERVER_NAME}_${SERVER_TYPE}_dev

# 测试环境的编译发布
build-test:

	GOOS=linux GOARCH=amd64 CGO_ENABLED=0 go build -o bin/${SERVER_NAME}-${SERVER_TYPE} ./apps/${SERVER_NAME}/${SERVER_TYPE}/${SERVER_NAME}.go
	docker build . -f ${DOCKER_FILE_TEST} --no-cache -t ${APP_NAME_TEST}

# 镜像的测试标签
tag-test:

	@echo 'create tag ${VERSION_TEST}'
	docker tag ${APP_NAME_TEST} ${DOCKER_REPO_TEST}:${VERSION_TEST}

publish-test:

	@echo 'publish ${VERSION_TEST} to ${DOCKER_REPO_TEST}'
	docker push $(DOCKER_REPO_TEST):${VERSION_TEST}

release-test: build-test tag-test publish-test

```

可能会有很多这种mk或者sh，所以在在最外面写一个大mk调用所有的这种脚本

>   easy-chat/Makefile

```makefile
user-rpc-dev:
	@make -f deploy/mk/user-rpc.mk release-test

release-test: user-rpc-dev
```

然后这个项目的开发，运用两个虚拟机模拟

>   192.168.88.129 —开发机 ---------> 构建镜像，上传至仓库
>
>   192.168.88.130 —测试部署机（宿主机）--------->拉取镜像运行

现在我们在本地完成了部分的开发，将代码上传至开发机

```
ssh onychen@192.168.88.129 "rm -rf ~/easy-chat"                      
scp -r d:\code\go\easy-chat onychen@192.168.88.129:~/easy-chat

```

然后再开发机上执行mk文件,尝试编译项目并构建镜像后上传

```
make release-test
```

项目一堆依赖环境没下过，然后开始疯狂问ai，下载相关依赖

然后user-rpc的镜像是构建好了，还差环境的-mysql,redis,etcd等

所以这用到docker-compose进行编排

>   /easy-chat/docker-compose.yaml

```yaml
version: '3'

services:
  etcd:
    image: quay.io/coreos/etcd:v3.4.15
    container_name: etcd
    ports:
      - "3379:2379"
      - "3380:2380"
    environment:
      - ETCD_ADVERTISE_CLIENT_URLS=http://192.168.88.130:3379
      - ETCD_LISTEN_CLIENT_URLS=http://0.0.0.0:2379
      - ETCD_NAME=etcd
    volumes:
      - ./components/etcd/data:/etcd-data
    networks:
      easy-chat:
    command: etcd --data-dir=/etcd-data --enable-v2=true

  redis:
    image: redis:alpine3.18
    ports:
      - 16379:6379
    container_name: redis
    volumes:
      - ./components/redis/data:/data
      - ./components/redis/config/redis.conf:/usr/local/redis/config/redis.conf
    environment:
      TZ: Asia/Shanghai
    restart: always
    networks:
      easy-chat:
    command: redis-server --requirepass easy-chat --appendonly yes

  mysql:
    image: mysql:5.7
    ports:
      - 13306:3306
    container_name: mysql
    volumes:
      - ./components/mysql/data:/var/lib/mysql
      - /etc/localtime:/etc/localtime
    environment:
      MYSQL_ROOT_PASSWORD: easy-chat
    restart: always
    networks:
      easy-chat:


networks:
  easy-chat:
    driver: bridge

```

然后传到宿主机上，拉取构建

```
ssh onychen@192.168.88.130 "rm -rf ~/easy-chat"    
scp -r d:\code\go\easy-chat onychen@192.168.88.130:~/easy-chat
```

在宿主机终端

```
docker-compose up -d
```

然后三个服务环境就弄好了mysql redis etcd

（这里一开始etcd用了bitnami/etcd:3.4.15一直拉不到，问ai给我换了个镜像
换了一堆都不行，最后找到quay.io/coreos/etcd:v3.4.15）



由于现在我们的目的是上传镜像之后，拉取镜像实现服务，如果本地有镜像，会优先本地拉取，无法实现我们的目标，所以我们在拉取仓库镜像之前要先删掉本地镜像，而dockercompose无法实现这个操作，所以我们的user-rpc镜像的构建不编排在dockercompose里，但因为这又涉及到一系列重复命令操作，这里写一个shell文件一键化实现

重复操作

```
docker login --username=t_1478801769083_0 crpi-osk929019sdokpya.cn-guangzhou.personal.cr.aliyuncs.com/easy-ct/user-rpc-dev

docker stop container_name
docker rm container_name
docker rmi images_name
docker pull images_name
docker run --name container_name images_name
```

所以写一个sh

>   /easy-chat/deploy/script/user-rpc-test.mk

```sh
#!/bin/bash

reso_addr='crpi-osk929019sdokpya.cn-guangzhou.personal.cr.aliyuncs.com/easy-ct/user-rpc-dev'
tag='latest'

echo "登录阿里云镜像仓库..."
docker login --username=onychen crpi-osk929019sdokpya.cn-guangzhou.personal.cr.aliyuncs.com

pod_ip="192.168.88.130"

container_name="easy-chat-user-rpc-test"

docker stop ${container_name}

docker rm ${container_name}

docker rmi ${reso_addr}:${tag}

docker pull ${reso_addr}:${tag}


docker run -p 10000:10000 -e POD_IP=${pod_ip}  --name=${container_name} -d ${reso_addr}:${tag}
```

然后在写一个总的release.sh用于一键启动所有sh

>   /easy-chat/deploy/script/release-test.mk

```sh
#!/bin/bash

need_start_server_shell=(
    "user-rpc-test.sh"
)

for i in ${need_start_server_shell[*]} ; do
    chmod +x $i
    ./$i
done


docker ps

docker exec -it etcd etcdctl get --prefix ""
```

然后更新大mk

>   /easy-chat/Makefile

```makefile
user-rpc-dev:
	@make -f deploy/mk/user-rpc.mk release-test

release-test: user-rpc-dev

install-server:
	cd ./deploy/script && chmod +x release-test.sh && ./release-test.sh
```

然后就可以拉去宿主机测试了

```
ssh onychen@192.168.88.130 "rm -rf ~/easy-chat"    
scp -r d:\code\go\easy-chat onychen@192.168.88.130:~/easy-chat
```

```
make install-server
```

这里一开始sh没加登录阿里云仓库的代码，一直忘记登录，没法拉取，闹麻了

然后才拉取成功

![image-20260215153428715](../../../PHOTOS/image-20260215153428715.png)

接下来用postman测试一下

![image-20260215153449994](../../../PHOTOS/image-20260215153449994.png)

成功相应ping



### 完成user-用户服务注册登入功能

先看用户表和用户模型

>   /easy-chat/deploy/sql/user.sql

```sql
CREATE TABLE `users` (
         `id` varchar(24) COLLATE utf8mb4_unicode_ci  NOT NULL ,
         `avatar` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '',
         `nickname` varchar(24) COLLATE utf8mb4_unicode_ci NOT NULL,
         `phone` varchar(20) COLLATE utf8mb4_unicode_ci NOT NULL,
         `password` varchar(191) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
         `status` tinyint COLLATE utf8mb4_unicode_ci DEFAULT NULL,
         `sex` tinyint COLLATE utf8mb4_unicode_ci DEFAULT NULL,
         `created_at` timestamp NULL DEFAULT NULL,
         `updated_at` timestamp NULL DEFAULT NULL,
         PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

然后用goctl构建model

```
goctl model mysql ddl -src="./deploy/sql/user.sql" -dir="./apps/user/models/" -c
```

在目录结构中，将数据模型层与rpc层同级，因为在项目中除rpc需要调用usermodel外，在服务中也有针对该服务所定义的计划任务或者api、也需要model中的数据结构，因此在目录的设计上是将models与rpc同级，在models中我们会定义针对user服务系统会使用到的共享数据结构及常量。

![image-20260215170244430](../../../PHOTOS/image-20260215170244430.png)

接下来就该实现注册和登入的功能了

注册功能

验证是否存在用户即(手机号码or用户名)

(对密码加密)

新增用户

(生成token)



打算先加个按照手机查询的方法

照着下面改一下即可

>   /easy-chat/apps/user/models/usersmodel_gen.go

```go
func (m *defaultUsersModel) FindOne(ctx context.Context, id string) (*Users, error) {
	usersIdKey := fmt.Sprintf("%s%v", cacheUsersIdPrefix, id)
	var resp Users
	err := m.QueryRowCtx(ctx, &resp, usersIdKey, func(ctx context.Context, conn sqlx.SqlConn, v any) error {
		query := fmt.Sprintf("select %s from %s where `id` = ? limit 1", usersRows, m.table)
		return conn.QueryRowCtx(ctx, v, query, id)
	})
	switch err {
	case nil:
		return &resp, nil
	case sqlc.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}
```

⬇

```go
func (m *defaultUsersModel) FindByPhone(ctx context.Context, phone string) (*Users, error) {
	usersIdKey := fmt.Sprintf("%s%v", cacheUsersIdPrefix, phone)
	var resp Users
	err := m.QueryRowCtx(ctx, &resp, usersIdKey, func(ctx context.Context, conn sqlx.SqlConn, v any) error {
		query := fmt.Sprintf("select %s from %s where `phone` = ? limit 1", usersRows, m.table)
		return conn.QueryRowCtx(ctx, v, query, phone)
	})
	switch err {
	case nil:
		return &resp, nil
	case sqlc.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}
```

记得在上面模型方法定义上补上这个函数

![image-20260215200943539](../../../PHOTOS/image-20260215200943539.png)





密码加密

encrypt

>   /easy-chat/pkg/encrypt/hash.go

```go
/**
 * @author: dn-jinmin/dn-jinmin
 * @doc:
 */

package encrypt

import (
	"crypto/md5"
	"encoding/hex"
	"golang.org/x/crypto/bcrypt"
)

func Md5(str []byte) string {
	h := md5.New()
	h.Write(str)
	return hex.EncodeToString(h.Sum(nil))
}

// hash加密
func GenPasswordHash(password []byte) ([]byte, error) {
	return bcrypt.GenerateFromPassword(password, bcrypt.DefaultCost)
}

// hash校验
func ValidatePasswordHash(password string, hashed string) bool {
	if err := bcrypt.CompareHashAndPassword([]byte(hashed), []byte(password)); err != nil {
		return false
	}
	return true
}

```

jwt生成

生成 - rpc
验证 - api (gozero已经生成了这个中间件了？)

生成之后我们会存储一些信息，验证之后信息会放进context中

所以在pkg在开一个ctxdata

<img src="../../../PHOTOS/image-20260215202031354.png" alt="image-20260215202031354" style="zoom:33%;" />

生成一个基于 JWT (JSON Web Token) 标准的身份认证令牌

>   /easy-chat/pkg/ctxdata/token.go

```go
package ctxdata

import "github.com/golang-jwt/jwt"

const Identify = "onychen"

func GetJwtToken(secretKey string, iat, seconds int64, uid string) (string, error) {
	claims := make(jwt.MapClaims)
	claims["exp"] = iat + seconds
	claims["iat"] = iat
	claims[Identify] = uid

	token := jwt.New(jwt.SigningMethodHS256)
	token.Claims = claims

	return token.SignedString([]byte(secretKey))
}

```

>   /easy-chat/pkg/ctxdata/data.go

```go
package ctxdata

import "context"

func GetUId(ctx context.Context) string {
	if u, ok := ctx.Value(Identify).(string); ok {
		return u
	}
	return ""
}

```

id 生成工具，

关于id可以最简单的直接使用自增，如果考虑后续数据量的增长过大的需拆分数据库的时候则需要细节思考，这里我们采用第三方库wuid来生成id

可获取一个不重复id

>   /easy-chat/pkg/wuid/wuid.go

```go
package wuid

import (
	"database/sql"
	"fmt"
	"sort"
	"strconv"

	"github.com/edwingeng/wuid/mysql/wuid"
)

var w *wuid.WUID

func Init(dsn string) {

	newDB := func() (*sql.DB, bool, error) {
		db, err := sql.Open("mysql", dsn)
		if err != nil {
			return nil, false, err
		}
		return db, true, nil
	}

	w = wuid.NewWUID("default", nil)
	_ = w.LoadH28FromMysql(newDB, "wuid")
}

func GenUid(dsn string) string {
	if w == nil {
		Init(dsn)
	}

	return fmt.Sprintf("%#016x", w.Next())
}

func CombineId(aid, bid string) string {
	ids := []string{aid, bid}

	sort.Slice(ids, func(i, j int) bool {
		a, _ := strconv.ParseUint(ids[i], 0, 64)
		b, _ := strconv.ParseUint(ids[j], 0, 64)
		return a < b
	})

	return fmt.Sprintf("%s_%s", ids[0], ids[1])
}

```

工具准备完成

准备完善业务

完善业务前要先定义下配置

>   /easy-chat/apps/user/rpc/etc/dev/user.yaml

```yaml
Name: user.rpc
ListenOn: 0.0.0.0:10000
Etcd:
  Hosts:
  - 192.168.88.130:3379
  Key: user.rpc

Mysql:
  DataSource: root:easy-chat@tcp(192.168.88.130:13306)/easy-chat?charset=utf8mb4

Cache:
  - Host: 192.168.88.130:16379
    Type: node
    Pass: easy-chat

Jwt:
  AccessSecret: onychen
  AccessExpire: 8640000
```

三个属性配置完成后，继续添加下结构体

>   /easy-chat/apps/user/rpc/internal/config/config.go

```go
package config

import (
	"github.com/zeromicro/go-zero/core/stores/cache"
	"github.com/zeromicro/go-zero/zrpc"
)

type Config struct {
	zrpc.RpcServerConf

	Mysql struct {
		DataSource string
	}

	Cache cache.CacheConf

	Jwt struct {
		AccessSecret string
		AccessExpire int64
	}
}

```

然后把模型加入servicecontext中

>   /easy-chat/apps/user/rpc/svc/servicecontext.go

```go
package svc

import (
	"easy-chat/apps/user/models"
	"easy-chat/apps/user/rpc/internal/config"

	"github.com/zeromicro/go-zero/core/stores/sqlx"
)

type ServiceContext struct {
	Config config.Config

	models.UsersModel
}

func NewServiceContext(c config.Config) *ServiceContext {
	sqlConn := sqlx.NewMysql(c.Mysql.DataSource)

	return &ServiceContext{
		Config: c,

		UsersModel: models.NewUsersModel(sqlConn, c.Cache),
	}
}

```

然后就可以开始写注册登入业务了

大概业务流程其实就是

读入之后
先检查手机号是否被注册过
没有的话就可以定义用户信息了
然后对密码进行加密，然后调用模型的insert
然后就可以生成token了
最后返回resp

>   /easy-chat/apps/user/rpc/internal/logic/registerlogic.go

```go
package logic

import (
	"context"
	"database/sql"
	"errors"
	"easy-chat/apps/user/models"
	"easy-chat/pkg/ctxdata"
	"easy-chat/pkg/encrypt"
	"easy-chat/pkg/wuid"
	"time"

	"easy-chat/apps/user/rpc/internal/svc"
	"easy-chat/apps/user/rpc/user"

	"github.com/zeromicro/go-zero/core/logx"
)

var (
	ErrPhoneIsRegister = errors.New("手机号已经注册过")
)

type RegisterLogic struct {
	ctx    context.Context
	svcCtx *svc.ServiceContext
	logx.Logger
}

func NewRegisterLogic(ctx context.Context, svcCtx *svc.ServiceContext) *RegisterLogic {
	return &RegisterLogic{
		ctx:    ctx,
		svcCtx: svcCtx,
		Logger: logx.WithContext(ctx),
	}
}

func (l *RegisterLogic) Register(in *user.RegisterReq) (*user.RegisterResp, error) {
	// todo: add your logic here and delete this line

	// 1. 验证用户是否注册，根据手机号码验证
	userEntity, err := l.svcCtx.UsersModel.FindByPhone(l.ctx, in.Phone)
	if err != nil && err != models.ErrNotFound {
		return nil, err
	}

	if userEntity != nil {
		return nil, ErrPhoneIsRegister
	}

	// 定义用户数据
	userEntity = &models.Users{
		Id:       wuid.GenUid(l.svcCtx.Config.Mysql.DataSource),
		Avatar:   in.Avatar,
		Nickname: in.Nickname,
		Phone:    in.Phone,
		Sex: sql.NullInt64{
			Int64: int64(in.Sex),
			Valid: true,
		},
	}

	if len(in.Password) > 0 {
		genPassword, err := encrypt.GenPasswordHash([]byte(in.Password))
		if err != nil {
			return nil, err
		}
		userEntity.Password = sql.NullString{
			String: string(genPassword),
			Valid:  true,
		}
	}

	_, err = l.svcCtx.UsersModel.Insert(l.ctx, userEntity)
	if err != nil {
		return nil, err
	}

	// 生成token
	now := time.Now().Unix()
	token, err := ctxdata.GetJwtToken(l.svcCtx.Config.Jwt.AccessSecret, now, l.svcCtx.Config.Jwt.AccessExpire,
		userEntity.Id)
	if err != nil {
		return nil, err
	}

	return &user.RegisterResp{
		Token:  token,
		Expire: now + l.svcCtx.Config.Jwt.AccessExpire,
	}, nil
}

```

登入业务类似，照着改即可

大概流程
检查登入是输入的手机号也没有被注册过
然后检查密码是否正确
然后就可以发token了

>   /easy-chat/apps/user/rpc/internal/logic/loginlogic.go

```go
package logic

import (
	"context"

	"github.com/pkg/errors"

	"easy-chat/apps/user/models"
	"easy-chat/apps/user/rpc/internal/svc"
	"easy-chat/apps/user/rpc/user"
	"easy-chat/pkg/ctxdata"
	"easy-chat/pkg/encrypt"
	"time"

	"github.com/zeromicro/go-zero/core/logx"
)

var (
	ErrPhoneNotRegister = errors.New("手机号没有注册")
	ErrUserPwdError     = errors.New("密码不正确")
)

type LoginLogic struct {
	ctx    context.Context
	svcCtx *svc.ServiceContext
	logx.Logger
}

func NewLoginLogic(ctx context.Context, svcCtx *svc.ServiceContext) *LoginLogic {
	return &LoginLogic{
		ctx:    ctx,
		svcCtx: svcCtx,
		Logger: logx.WithContext(ctx),
	}
}

func (l *LoginLogic) Login(in *user.LoginReq) (*user.LoginResp, error) {
	// todo: add your logic here and delete this line

	// 1. 验证用户是否注册，根据手机号码验证
	userEntity, err := l.svcCtx.UsersModel.FindByPhone(l.ctx, in.Phone)
	if err != nil {
		if err != models.ErrNotFound {
			return nil, ErrPhoneNotRegister
		}
		return nil, err
	}

	// 密码验证
	if !encrypt.ValidatePasswordHash(in.Password, userEntity.Password.String) {
		return nil, ErrUserPwdError
	}

	// 生成token
	now := time.Now().Unix()
	token, err := ctxdata.GetJwtToken(l.svcCtx.Config.Jwt.AccessSecret, now, l.svcCtx.Config.Jwt.AccessExpire,
		userEntity.Id)
	if err != nil {
		return nil, err
	}

	return &user.LoginResp{
		Token:  token,
		Expire: now + l.svcCtx.Config.Jwt.AccessExpire,
	}, nil
}

```

业务写完，可以进行一定测试，这里学习单列测试

由于测试就涉及调用logic里的方法，而每个方法都要传入一个servicecontext所以这里logic_text.go作用就是初始化一个svc供所有测试使用

>   /easy-chat/apps/user/rpc/internal/logic/logic_test.go

```go
package logic

import (
	"easy-chat/apps/user/rpc/internal/config"
	"easy-chat/apps/user/rpc/internal/svc"
	"path/filepath"

	"github.com/zeromicro/go-zero/core/conf"
)

var svcCtx *svc.ServiceContext

func init() {
	var c config.Config
	conf.MustLoad(filepath.Join("../../etc/dev/user.yaml"), &c)
	svcCtx = svc.NewServiceContext(c)
}

```

把光标放在你需要测试的函数里
<img src="../../../PHOTOS/image-20260216002145512.png" alt="image-20260216002145512" style="zoom:50%;" />

然后右键找到

<img src="../../../PHOTOS/image-20260216002213219.png" alt="image-20260216002213219" style="zoom:50%;" />

<img src="../../../PHOTOS/image-20260216002251469.png" alt="image-20260216002251469" style="zoom:50%;" />

就可以在当前目录下生成一个{funcname}_test.go

```go
package logic

import (
	"context"
	"easy-chat/apps/user/rpc/user"
	"testing"
)

func TestRegisterLogic_Register(t *testing.T) {
	type args struct {
		in *user.RegisterReq
	}
	tests := []struct {
		name string // description of this test case
		// Named input parameters for target function.
		args args
		// Named output parameters for target function.
		want    bool
		wantErr bool
	}{
		// TODO: Add test cases.
		{
			name: "Register success",
			args: args{
				in: &user.RegisterReq{
					Phone:    "13800000000",
					Nickname: "test",
					Password: "123456",
					Avatar:   "png.jpg",
					Sex:      1,
				},
			},
			want:    true,
			wantErr: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			l := NewRegisterLogic(context.Background(), svcCtx)
			got, gotErr := l.Register(tt.args.in)
			if gotErr != nil {
				if !tt.wantErr {
					t.Errorf("Register() failed: %v", gotErr)
				}
				return
			}
			if tt.wantErr {
				t.Fatal("Register() succeeded unexpectedly")
			}
			// TODO: update the condition below to compare got with tt.want.
			if true {
				t.Log(tt.name, got)
			}
		})
	}
}

```

然后这里<img src="../../../PHOTOS/image-20260216002448838.png" alt="image-20260216002448838" style="zoom:50%;" />

<img src="../../../PHOTOS/image-20260216002511634.png" alt="image-20260216002511634" style="zoom:50%;" />

然后mysql也成功写入了

<img src="../../../PHOTOS/image-20260216002538798.png" alt="image-20260216002538798" style="zoom:50%;" />

perfect

当然也可以用apipost测试



### 用户服务中搜索，用户信息功能实现

获取用户信息，其实就是根据id返回用户信息

>   /apps/user/rpc/logic/getuserinfologic.go

```go
package logic

import (
	"context"

	"easy-chat/apps/user/models"
	"easy-chat/apps/user/rpc/internal/svc"
	"easy-chat/apps/user/rpc/user"
	"errors"

	"github.com/jinzhu/copier"

	"github.com/zeromicro/go-zero/core/logx"
)

var ErrUserNotFound = errors.New("这个用户没有")

type GetUserInfoLogic struct {
	ctx    context.Context
	svcCtx *svc.ServiceContext
	logx.Logger
}

func NewGetUserInfoLogic(ctx context.Context, svcCtx *svc.ServiceContext) *GetUserInfoLogic {
	return &GetUserInfoLogic{
		ctx:    ctx,
		svcCtx: svcCtx,
		Logger: logx.WithContext(ctx),
	}
}

func (l *GetUserInfoLogic) GetUserInfo(in *user.GetUserInfoReq) (*user.GetUserInfoResp, error) {
	// todo: add your logic here and delete this line

	userEntiy, err := l.svcCtx.UsersModel.FindOne(l.ctx, in.Id)
	if err != nil {
		if err == models.ErrNotFound {
			return nil, ErrUserNotFound
		}
		return nil, err
	}
	var resp user.UserEntity
	copier.Copy(&resp, userEntiy)

	return &user.GetUserInfoResp{
		User: &resp,
	}, nil
}

```

userEntiy是models.Users类型，resp是user.UserEntity类型
所以这里用到一个copier组件

<img src="../../../PHOTOS/image-20260216092242021.png" alt="image-20260216092242021" style="zoom:50%;" />

用户搜索

通过电话，名字，id获取用户信息

电话之前已经写了差个名字和id，id好写，名字需要模糊查询

新增功能先修改proto文件

>   /apps/user/rpc/user.proto

```
message FindUserReq {
  string name = 1;
  string phone = 2;
  repeated string ids = 3;
}

message FindUserResp {
  repeated UserEntity user = 1;
}

service User {
  rpc FindUser(FindUserReq) returns (FindUserResp);
}
```

然后涉及操作数据库的方法是在models写的

在查询的功能中，使用的是非缓存的方式进行查询，请求是直接走的数据库，在go中对集合的数据查询是没有做缓存处理。

>   /apps/user/models/usersmodel_gen.go

```go
type (
  	usersModel interface {
		ListByName(ctx context.Context, name string) ([]*Users, error)
		ListByIds(ctx context.Context, ids []string) ([]*Users, error)
	}
)

func (m *defaultUsersModel) ListByName(ctx context.Context, name string) ([]*Users, error) {
	query := fmt.Sprintf("select %s from %s where `nickname` like ? ", usersRows, m.table)

	var resp []*Users
	err := m.QueryRowsNoCacheCtx(ctx, &resp, query, fmt.Sprint("%", name, "%"))
	switch err {
	case nil:
		return resp, nil
	default:
		return nil, err
	}
}

func (m *defaultUsersModel) ListByIds(ctx context.Context, ids []string) ([]*Users, error) {
	query := fmt.Sprintf("select %s from %s where `id` in ('%s') ", usersRows, m.table, strings.Join(ids, "','"))

	var resp []*Users
	err := m.QueryRowsNoCacheCtx(ctx, &resp, query)
	switch err {
	case nil:
		return resp, nil
	default:
		return nil, err
	}
}
```

apipost测试一下

<img src="../../../PHOTOS/image-20260216145845998.png" alt="image-20260216145845998" style="zoom:50%;" />

<img src="../../../PHOTOS/image-20260216145907146.png" alt="image-20260216145907146" style="zoom:50%;" />

<img src="../../../PHOTOS/image-20260216145922507.png" alt="image-20260216145922507" style="zoom:50%;" />

成功



接下来学习一下错误处理

<img src="../../../PHOTOS/image-20260216143620283.png" alt="image-20260216143620283" style="zoom:50%;" />

针对错误处理目前的方式是将系统错误信息直接返回给了调用者，从程序上着不是特别友好没有做异常的处理。在程序中对异常处理主要有异常信息，状态码及后续异常产生的日志信息，我们可以使用go-zero中提供了对errors处理的方式https://go-zero.dev/docs/tutorials/http/server/error。

>   /pkg/xerr/err_code.go

```go
package xerr

const (
	SERVER_COMMON_ERROR = 100001
	REQUEST_PARAM_ERROR = 100002
	TOKEN_EXPIRE_ERROR = 100003
	DB_ERROR           = 100004
)
```

错误信息映射

>   /pkg/xerr/err_msg.go

```go
package xerr

var codeText = map[int]string{
	SERVER_COMMON_ERROR: "服务异常，请稍后处理",
	REQUEST_PARAM_ERROR: "参数不正确",
	TOKEN_EXPIRE_ERROR:  "token失效，请重新登陆",
	DB_ERROR:            "数据库繁忙,请稍后再试",
}

func ErrMsg(errcode int) string {
	if msg, ok := codeText[errcode]; ok {
		return msg
	}
	return codeText[SERVER_COMMON_ERROR]
}
```

错误处理封装 

>   /pkg/xerr/errors.go

```go
package xerr

import "github.com/zeromicro/x/errors"

func New(code int, msg string) error {
	return errors.New(code, msg)
}

func NewMsgErr(msg string) error {
	return errors.New(SERVER_COMMON_ERROR, msg)
}

func NewCodeErr(code int) error {
	return errors.New(code, ErrMsg(code))
}

func NewInternalErr() error {
	return errors.New(SERVER_COMMON_ERROR, ErrMsg(SERVER_COMMON_ERROR))
}

func NewDBErr() error {
	return errors.New(DB_ERROR, ErrMsg(DB_ERROR))
}

func NewReqParamErr() error {
	return errors.New(REQUEST_PARAM_ERROR, ErrMsg(REQUEST_PARAM_ERROR))
}
```

修改loginlogic演示一下

>   /easy-chat/apps/user/rpc/internal/logic/loginlogic.go

```go
package logic

import (
	"context"
	"easy-chat/pkg/xerr"

	"github.com/pkg/errors"

	"easy-chat/apps/user/models"
	"easy-chat/apps/user/rpc/internal/svc"
	"easy-chat/apps/user/rpc/user"
	"easy-chat/pkg/ctxdata"
	"easy-chat/pkg/encrypt"
	"time"

	"github.com/zeromicro/go-zero/core/logx"
)

var (
	ErrPhoneNotRegister = xerr.New(xerr.SERVER_COMMON_ERROR, "手机号没有注册")
	ErrUserPwdError     = xerr.New(xerr.SERVER_COMMON_ERROR, "密码不正确")
)

type LoginLogic struct {
	ctx    context.Context
	svcCtx *svc.ServiceContext
	logx.Logger
}

func NewLoginLogic(ctx context.Context, svcCtx *svc.ServiceContext) *LoginLogic {
	return &LoginLogic{
		ctx:    ctx,
		svcCtx: svcCtx,
		Logger: logx.WithContext(ctx),
	}
}

func (l *LoginLogic) Login(in *user.LoginReq) (*user.LoginResp, error) {
	// todo: add your logic here and delete this line

	// 1. 验证用户是否注册，根据手机号码验证
	userEntity, err := l.svcCtx.UsersModel.FindByPhone(l.ctx, in.Phone)
	if err != nil {
		if err == models.ErrNotFound {
			return nil, errors.WithStack(ErrPhoneNotRegister)
		}
		return nil, errors.Wrapf(xerr.NewDBErr(), "find user by phone err %v , req %v", err, in.Phone)
	}

	// 密码验证
	if !encrypt.ValidatePasswordHash(in.Password, userEntity.Password.String) {
		return nil, errors.WithStack(ErrUserPwdError)
	}

	// 生成token
	now := time.Now().Unix()
	token, err := ctxdata.GetJwtToken(l.svcCtx.Config.Jwt.AccessSecret, now, l.svcCtx.Config.Jwt.AccessExpire,
		userEntity.Id)
	if err != nil {
		return nil, errors.Wrapf(xerr.NewDBErr(), "ctxdata get jwt token err %v", err)
	}

	return &user.LoginResp{
		Token:  token,
		Expire: now + l.svcCtx.Config.Jwt.AccessExpire,
	}, nil
}

```

apipost看看效果

<img src="../../../PHOTOS/image-20260216150031938.png" alt="image-20260216150031938" style="zoom:50%;" />

对用户的反馈写好了，现在是要写回日志中

这里需要一个中间件，由于这个错误返回日志，几乎所有服务都要用，所以可以放在pkg

RPC 日志拦截器 

>   /easy-chat/pkg/interceptor/rpcserver/logInterceptor.go

```go
package rpcserver

import (
	"context"

	"github.com/pkg/errors"
	"github.com/zeromicro/go-zero/core/logx"
	zerr "github.com/zeromicro/x/errors"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

func LogInterceptor(ctx context.Context, req any, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (resp any,
	err error) {
	resp, err = handler(ctx, req)
	if err == nil {
		return resp, nil
	}

	logx.WithContext(ctx).Errorf("【RPC SRV ERR】 %v", err)

	causeErr := errors.Cause(err)
	if e, ok := causeErr.(*zerr.CodeMsg); ok {
		err = status.Error(codes.Code(e.Code), e.Msg)
	}

	return resp, err
}
```

用户服务入口文件改造 

>   /easy-chat//apps/user/user.go

```go
var configFile = flag.String("f", "etc/dev/user.yaml", "the config file")

func main() {
	flag.Parse()

	var c config.Config
	conf.MustLoad(*configFile, &c)
	ctx := svc.NewServiceContext(c)

	if err := ctx.SetRootToken(); err != nil {
		panic(err)
	}

	s := zrpc.MustNewServer(c.RpcServerConf, func(grpcServer *grpc.Server) {
		user.RegisterUserServer(grpcServer, server.NewUserServer(ctx))

		if c.Mode == service.DevMode || c.Mode == service.TestMode {
			reflection.Register(grpcServer)
		}
	})
	s.AddUnaryInterceptors(rpcserver.LogInterceptor)
	defer s.Stop()

	fmt.Printf("Starting rpc server at %s...\n", c.ListenOn)
	s.Start()
}
```

效果示意

![image-20260216200536421](../../../PHOTOS/image-20260216200536421.png)

一开始把grpc请求打到127.0.0.1:10000一直没有错误日志，然后打到localhost:10000就有了，给我整麻了

问了下ai说是

<img src="../../../PHOTOS/image-20260216200644255.png" alt="image-20260216200644255" style="zoom:50%;" />

<img src="../../../PHOTOS/image-20260216200704523.png" alt="image-20260216200704523" style="zoom:50%;" />



接下来该写api服务了

目录结构

```
- apps
  - user
    - api
      - user.api
      - domain.api
```

在 api 文件中用 user.api 定义服务中存储的 api 方法，而在 domain.api 中则存储用户 api 服务的模型实例对象的数据结构。

>   /apps/user/api/domain.api

```plain\
syntax = "v1"

info (
    title: "用户服务的实例对象"
    author: "onychen"
)

type User {
    Id       string `json:"id"`
    Mobile   string `json:"mobile"`
    Nickname string `json:"nickname"`
    Sex      byte   `json:"sex"`
    Avatar   string `json:"avatar"`
}

type (
    RegisterReq {
        Phone       string `json:"phone"`
        Password    string `json:"password"`
        Nickname    string `json:"nickname"`
        Sex         byte   `json:"sex"`
        Avatar      string `json:"avatar"`
    }
    RegisterResp {
        Token   string `json:"token"`
        Expire  int64  `json:"expire"`
    }
)

type (
    LoginReq {
         Phone       string `json:"phone"`
         Password    string `json:"password"`
    }
    LoginResp {
        Token   string `json:"token"`
        Expire  int64  `json:"expire"`
    }
)

type (
    UserInfoReq {}
    UserInfoResp {
        Info User `json:"info"`
    }
)
```

>   /apps/user/api/domain.api

```
syntax = "v1"

info (
    title: "用户服务的实例对象"
    author: "onychen"
)

type User {
    Id       string `json:"id"`
    Mobile   string `json:"mobile"`
    Nickname string `json:"nickname"`
    Sex      byte   `json:"sex"`
    Avatar   string `json:"avatar"`
}

type (
    RegisterReq {
        Phone       string `json:"phone"`
        Password    string `json:"password"`
        Nickname    string `json:"nickname"`
        Sex         byte   `json:"sex"`
        Avatar      string `json:"avatar"`
    }
    RegisterResp {
        Token   string `json:"token"`
        Expire  int64  `json:"expire"`
    }
)

type (
    LoginReq {
         Phone       string `json:"phone"`
         Password    string `json:"password"`
    }
    LoginResp {
        Token   string `json:"token"`
        Expire  int64  `json:"expire"`
    }
)

type (
    UserInfoReq {}
    UserInfoResp {
        Info User `json:"info"`
    }
)
```

在上面的定义中，我们对userinfo这个方法应用了jwt中间件进行了权限验证，在go-zero中内部就已经封装好了关于jwt验证的机制。

然后我们通过如下命令构建服务

```shell
easy-chat> goctl api go -api apps/user/api/user.api -dir apps/user/api -style gozero
```

修改一下配置

>   /easy-chat/apps/user/api/etc/dev/user.yaml

```go
Name: user
Host: 0.0.0.0
Port: 8888

UserRpc:
  Etcd:
    Hosts:
    - 192.168.88.130:3379
    Key: user.rpc

Jwt:
  AccessSecret: onychen
  AccessExpire: 8640000
```

这里加了个dev文件夹user.go的configfile也要改一下地址

>   /easy-chat/apps/user/api/internal/config/config.go

```go
// Code scaffolded by goctl. Safe to edit.
// goctl 1.9.2

package config

import (
	"github.com/zeromicro/go-zero/rest"
	"github.com/zeromicro/go-zero/zrpc"
)

type Config struct {
	rest.RestConf

	UserRpc zrpc.RpcClientConf
	//需要连接rpc服务完成功能，所以加上rpc的配置

	JwtAuth struct {
		AccessSecret string
		//AccessExpire int64 // 业务已经定义了
	}
}

```

在服务核心实例对象中对 userclient 的引用 

>   /apps/user/api/internal/svc/servicecontext.go

```go
// Code scaffolded by goctl. Safe to edit.
// goctl 1.9.2

package svc

import (
	"easy-chat/apps/user/api/internal/config"
	"easy-chat/apps/user/rpc/userclient"

	"github.com/zeromicro/go-zero/zrpc"
)

type ServiceContext struct {
	Config config.Config
	userclient.User//
}

func NewServiceContext(c config.Config) *ServiceContext {
	return &ServiceContext{
		Config: c,
		User:   userclient.NewUser(zrpc.MustNewClient(c.UserRpc)),//
	}
}

```

准备工作完成，接下来完善业务接口

服务接口包含控制器和业务，控制器已经生成好了

>   /apps/user/api/internal/logic/user/loginlogic.go

```go
// Code scaffolded by goctl. Safe to edit.
// goctl 1.9.2

package user

import (
	"context"

	"easy-chat/apps/user/api/internal/svc"
	"easy-chat/apps/user/api/internal/types"
	"easy-chat/apps/user/rpc/user"

	"github.com/jinzhu/copier"
	"github.com/zeromicro/go-zero/core/logx"
)

type RegisterLogic struct {
	logx.Logger
	ctx    context.Context
	svcCtx *svc.ServiceContext
}

// 用户注册
func NewRegisterLogic(ctx context.Context, svcCtx *svc.ServiceContext) *RegisterLogic {
	return &RegisterLogic{
		Logger: logx.WithContext(ctx),
		ctx:    ctx,
		svcCtx: svcCtx,
	}
}

func (l *RegisterLogic) Register(req *types.RegisterReq) (resp *types.RegisterResp, err error) {
	registerResp, err := l.svcCtx.User.Register(l.ctx, &user.RegisterReq{
		Phone:    req.Phone,
		Nickname: req.Nickname,
		Password: req.Password,
		Avatar:   req.Avatar,
		Sex:      int32(req.Sex),
	})
	if err != nil {
		return nil, err
	}

	var res types.RegisterResp
	copier.Copy(&res, registerResp)

	return &res, nil
}

```

api 接口

在 api 服务的接口中我们会使用 userclient 发起对 userserver 服务的调度，完成 api 请求接口的业务

>   /apps/user/api/internal/logic/user/loginlogic.go

```go
// Code scaffolded by goctl. Safe to edit.
// goctl 1.9.2

package user

import (
	"context"

	"easy-chat/apps/user/api/internal/svc"
	"easy-chat/apps/user/api/internal/types"
	"easy-chat/apps/user/rpc/user"

	"github.com/jinzhu/copier"
	"github.com/zeromicro/go-zero/core/logx"
)

type LoginLogic struct {
	logx.Logger
	ctx    context.Context
	svcCtx *svc.ServiceContext
}

// 用户登入
func NewLoginLogic(ctx context.Context, svcCtx *svc.ServiceContext) *LoginLogic {
	return &LoginLogic{
		Logger: logx.WithContext(ctx),
		ctx:    ctx,
		svcCtx: svcCtx,
	}
}

func (l *LoginLogic) Login(req *types.LoginReq) (resp *types.LoginResp, err error) {
	loginResp, err := l.svcCtx.User.Login(l.ctx, &user.LoginReq{
		Phone:    req.Phone,
		Password: req.Password,
	})
	if err != nil {
		return nil, err
	}

	var res types.LoginResp
	copier.Copy(&res, loginResp)

	return &res, nil
}

```

注册服务 

>   /apps/user/api/internal/logic/user/registerlogic.go

```go
// Code scaffolded by goctl. Safe to edit.
// goctl 1.9.2

package user

import (
	"context"

	"easy-chat/apps/user/api/internal/svc"
	"easy-chat/apps/user/api/internal/types"
	"easy-chat/apps/user/rpc/user"

	"github.com/jinzhu/copier"
	"github.com/zeromicro/go-zero/core/logx"
)

type RegisterLogic struct {
	logx.Logger
	ctx    context.Context
	svcCtx *svc.ServiceContext
}

// 用户注册
func NewRegisterLogic(ctx context.Context, svcCtx *svc.ServiceContext) *RegisterLogic {
	return &RegisterLogic{
		Logger: logx.WithContext(ctx),
		ctx:    ctx,
		svcCtx: svcCtx,
	}
}

func (l *RegisterLogic) Register(req *types.RegisterReq) (resp *types.RegisterResp, err error) {
	registerResp, err := l.svcCtx.User.Register(l.ctx, &user.RegisterReq{
		Phone:    req.Phone,
		Nickname: req.Nickname,
		Password: req.Password,
		Avatar:   req.Avatar,
		Sex:      int32(req.Sex),
	})
	if err != nil {
		return nil, err
	}

	var res types.RegisterResp
	copier.Copy(&res, registerResp)

	return &res, nil
}

```

在用户详情服务中我们需要获取到用户的 id，可以通过在 pkg 下的 ctxdata 包获取。

>   /pkg/ctxdata/data.go

```go
package ctxdata

import "context"

func GetUId(ctx context.Context) string {
	if u, ok := ctx.Value(Identify).(string); ok {
		return u
	}
	return ""
}
```

>   /apps/user/api/internal/logic/user/detaillogic.go

```go
func (l *DetailLogic) Detail(req *types.UserInfoReq) (resp *types.UserInfoResp, err error) {
	uid := ctxdata.GetUId(l.ctx)

	userInfoResp, err := l.svcCtx.User.GetUserInfo(l.ctx, &user.GetUserInfoReq{
		Id: uid,
	})
	if err != nil {
		return nil, err
	}

	var res types.User
	copier.Copy(&res, userInfoResp.User)

	return &types.UserInfoResp{Info: res}, nil
}
```

测测你的

现在rpc go run . 之后去 api go run .

然后用postman发http请求测试
<img src="../../../PHOTOS/image-20260217135033444.png" alt="image-20260217135033444" style="zoom:50%;" /><img src="../../../PHOTOS/image-20260217135007830.png" alt="image-20260217135007830" style="zoom:50%;" />

响应输出

定义好对整体 api 服务的响应输出处理 

>   /pkg/resultx/httpResponse.go

```go
package resultx

import (
	"context"
	"net/http"

	"github.com/pkg/errors"
	"github.com/zeromicro/go-zero/core/logx"
	zrpcErr "github.com/zeromicro/x/errors"
	"google.golang.org/grpc/status"

	"easy-chat/pkg/xerr"
)

type Response struct {
	Code int         `json:"code"`
	Msg  string      `json:"msg"`
	Data interface{} `json:"data"`
}

func Success(data interface{}) *Response {
	return &Response{
		Code: 200,
		Msg:  "",
		Data: data,
	}
}

func Fail(code int, err string) *Response {
	return &Response{
		Code: code,
		Msg:  err,
		Data: nil,
	}
}

func OkHandler(_ context.Context, v interface{}) any {
	return Success(v)
}

func ErrHandler(name string) func(ctx context.Context, err error) (int, any) {
	return func(ctx context.Context, err error) (int, any) {
		errcode := xerr.SERVER_COMMON_ERROR
		errmsg := xerr.ErrMsg(errcode)

		causeErr := errors.Cause(err)
		if e, ok := causeErr.(*zrpcErr.CodeMsg); ok {
			errcode = e.Code
			errmsg = e.Msg
		} else {
			if gstatus, ok := status.FromError(causeErr); ok {
				errcode = int(gstatus.Code())
				errmsg = gstatus.Message()
			}
		}

		// 日志记录
		logx.WithContext(ctx).Errorf("【%s】 err %v", name, err)

		return http.StatusBadRequest, Fail(errcode, errmsg)
	}
}

```

使用：

>   /apps/user/api/user.go

```go
// Code scaffolded by goctl. Safe to edit.
// goctl 1.9.2

package main

import (
	"easy-chat/pkg/resultx"
	"flag"
	"fmt"

	"github.com/zeromicro/go-zero/rest/httpx"

	"easy-chat/apps/user/api/internal/config"
	"easy-chat/apps/user/api/internal/handler"
	"easy-chat/apps/user/api/internal/svc"

	"github.com/zeromicro/go-zero/core/conf"
	"github.com/zeromicro/go-zero/rest"
)

var configFile = flag.String("f", "etc/dev/user.yaml", "the config file")

func main() {
	flag.Parse()

	var c config.Config
	conf.MustLoad(*configFile, &c)

	server := rest.MustNewServer(c.RestConf)
	defer server.Stop()

	ctx := svc.NewServiceContext(c)
	handler.RegisterHandlers(server, ctx)

	httpx.SetErrorHandlerCtx(resultx.ErrHandler(c.Name))
	httpx.SetOkHandler(resultx.OkHandler)

	fmt.Printf("Starting server at %s:%d...\n", c.Host, c.Port)
	server.Start()
}

```

测测

<img src="../../../PHOTOS/image-20260217165158719.png" alt="image-20260217165158719" style="zoom:50%;" />



### 构建社交服务rpc**服务**并完成业务

围绕三个话题

-   数据表与模型
-   构建社区服务
-   好友与群业务

首先看数据表与模型

群信息，群与用户关联表，群申请表，好友关系表，好友申请表

在数据表结构中针对好友表的建议可以有两种方案：

#### 冗余处理

当用户 A 通过用户 B 的好友申请之后，即用户 A 与用户 B 互为好友的关系。

采取冗余的方式即，就是在 A 通过 B 的好友申请后，同时针对 A 和 B 建立两条数据并保存到数据库中。

**优点**：设计简单明了，查询也会简约快速

**缺点**：对数据库来说存在冗余

#### 计算唯一 key

该方案的方式是针对 A 和 B 在确定好友关系后，程序基于 A 的 id 和 B 的 id 做特定的固定运算，如对 A 和 B 的 id 做升序，然后再组合成一个字符串作为唯一的 key。

**优点**：A 和 B 在建立好友关系的时候，只会存储一条数据，同比上一方案，会减少空间

**缺点**：计算复杂，在查询某一个人的好友的时候 sql 的写法如下：

```sql
select * from friends where user_1_id = ? or user_2_id = ?

// 或者

select * from friends where user_1_id 
union all
select * from friends where user_2_id
```

构建社交服务

关于社交服务的构建与用户服务的构建是一致的，我们先编写好对应的.proto 文件，然后再通过 goctl 构建好项目程序。

>   /apps/social/rpc/social.proto

```go
syntax = "proto3";

package social;

option go_package = "./social";

// model
message Friends {
  int32  id = 1;
  string userId = 2;
  string remark = 3;
  int32  addSource = 4; // 添加来源
  string friendUid = 5;
}

message FriendRequests {
  int32  id = 1;
  string userId = 2;
  string reqUid = 3;
  string reqMsg = 4;
  int64  reqTime = 5;
  int32  handleResult = 6; // 处理结果
}

message Groups {
  string id = 1;
  string name = 2;
  string icon = 3;
  int32  status = 4;
  string creator_uid = 5;
  int32  groupType = 6;
  bool   isVerify = 7;
  string notification = 8; // 公告通知
  string notificationUid = 9;
}

message GroupMembers {
  int32  id = 1;
  string groupId = 2;
  string userId = 3;
  int32  roleLevel = 6;
  int64  joinTime = 7;
  int32  joinSource = 8;
  string inviterUid = 9;
  string operatorUid = 10;
}

message GroupRequests {
  int32  id = 1;
  string groupId = 2;
  string reqId = 3;
  string reqMsg = 4;
  int64  reqTime = 5;
  int32  joinSource = 6;
  string inviterUid = 7;
  string handleUid = 8;
  int32  handleResult = 9; // 处理结果
}

// req resp
message FriendPutInReq {
  string userId = 2;
  string reqUid = 3;
  string reqMsg = 4;
  int64  reqTime = 5;
}
message FriendPutInResp {}

message FriendPutInHandleReq {
  int32  friendReqId = 1;
  string userId = 2;
  int32 handleResult = 3; // 处理结果
}
message FriendPutInHandleResp {}

message FriendPutInListReq{
  string userId = 1;
}

message FriendPutInListResp{
  repeated FriendRequests list = 1;
}

message FriendListReq{
  string userId = 1;
}

message FriendListResp{
  repeated Friends list = 1;
}

// 群
message GroupCreateReq {
  string name = 2;
  string icon = 3;
  int32  status = 4;
  string creator_uid = 5;
}
message GroupCreateResp {}

message GroupPutinReq {
  string groupId = 2;
  string reqId = 3;
  string reqMsg = 4;
  int64  reqTime = 5;
  int32  joinSource = 6;
  string inviterUid = 7;
}
message GroupPutinResp {}

message GroupPutinListReq {
  string groupId = 1;
}
message GroupPutinListResp {
  repeated GroupRequests list = 1;
}

message GroupPutInHandleReq {
  int32  groupReqId = 1;
  string groupId = 2;
  string handleUid = 3;
  int32  handleResult = 4; // 处理结果

  string username = 6;
  string userAvatarUrl = 7;
}
message GroupPutInHandleResp {}

message GroupListReq{
  string userId = 1;
}
message GroupListResp{
  repeated Groups list = 1;
}

message GroupUsersReq {
  string groupId = 1;
}
message GroupUsersResp {
  repeated GroupMembers List = 1;
}

// svc
service social {
  // 好友业务：请求好友、通过或拒绝申请、好友列表
  rpc FriendPutIn(FriendPutInReq) returns(FriendPutInResp);
  rpc FriendPutInHandle(FriendPutInHandleReq) returns(FriendPutInHandleResp);
  rpc FriendPutInList(FriendPutInListReq) returns(FriendPutInListResp);
  rpc FriendList(FriendListReq) returns (FriendListResp);

  // 群业务：创建群，修改群，群公告，申请群，用户群列表，群成员，申请群，群退出..
  // 群要求
  rpc GroupCreate(GroupCreateReq) returns (GroupCreateResp);
  rpc GroupPutin(GroupPutinReq) returns (GroupPutinResp);
  rpc GroupPutinList(GroupPutinListReq) returns (GroupPutinListResp);
  rpc GroupPutInHandle(GroupPutInHandleReq) returns(GroupPutInHandleResp);
  rpc GroupList(GroupListReq) returns (GroupListResp);
  rpc GroupUsers(GroupUsersReq) returns (GroupUsersResp);

  // ..
}
```

运行

```shell
goctl rpc protoc apps/social/rpc/social.proto --go_out=./apps/social/rpc --go-grpc_out=./apps/social/rpc --zrpc_out=./apps/social/rpc
```

依旧是先改配置文件

>   /apps/social/rpc/etc/social.yaml

```yaml
Name: social.rpc
ListenOn: 0.0.0.0:10001

Etcd:
  Hosts:
  - 192.168.88.130:3379
  Key: social.rpc

Mysql:
  DataSource: root:easy-chat@tcp(192.168.88.130:13306)/easy-chat?charset=utf8mb4

Cache:
  - Host: 192.168.88.130:16379
    Type: node
    Pass: easy-chat
```

>   /apps/social/rpc/internal/config/config.yaml

```go
package config

import (
	"github.com/zeromicro/go-zero/core/cache"
	"github.com/zeromicro/go-zero/zrpc"
)

type Config struct {
	zrpc.RpcServerConf

	Mysql struct {
		DataSource string
	}

	Cache cache.CacheConf
}

```

提前准备好的sql文件

>   /deploy/sql/social.sql

```sql
CREATE TABLE `friends` (
   `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
   `user_id` varchar(64) COLLATE utf8mb4_unicode_ci  NOT NULL ,
   `friend_uid` varchar(64) COLLATE utf8mb4_unicode_ci  NOT NULL ,
   `remark` varchar(255) DEFAULT NULL,
   `add_source`  tinyint COLLATE utf8mb4_unicode_ci DEFAULT NULL,
   `created_at` timestamp NULL DEFAULT NULL,
   PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

CREATE TABLE `friend_requests` (
   `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
   `user_id` varchar(64) COLLATE utf8mb4_unicode_ci  NOT NULL ,
   `req_uid` varchar(64) COLLATE utf8mb4_unicode_ci  NOT NULL ,
   `req_msg` varchar(255) DEFAULT NULL,
   `req_time` timestamp  NOT NULL,
   `handle_result`  tinyint COLLATE utf8mb4_unicode_ci DEFAULT NULL,
   `handle_msg` varchar(255) DEFAULT NULL,
   `handled_at`timestamp NULL DEFAULT NULL,
   PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

CREATE TABLE `groups` (
 `id` varchar(24) COLLATE utf8mb4_unicode_ci  NOT NULL ,
  `name` varchar(255) COLLATE utf8mb4_unicode_ci  NOT NULL ,
  `icon` varchar(255) COLLATE utf8mb4_unicode_ci  NOT NULL ,
  `status`  tinyint COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `creator_uid` varchar(64) COLLATE utf8mb4_unicode_ci  NOT NULL ,
  `group_type` int(11) NOT NULL ,
  `is_verify` boolean NOT NULL ,
  `notification` varchar(255) DEFAULT NULL,
  `notification_uid` varchar(64) DEFAULT NULL,
  `created_at` timestamp NULL DEFAULT NULL,
  `updated_at` timestamp NULL DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

CREATE TABLE `group_members` (
 `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
 `group_id` varchar(64) COLLATE utf8mb4_unicode_ci  NOT NULL ,
 `user_id` varchar(64) COLLATE utf8mb4_unicode_ci  NOT NULL ,
 `role_level`  tinyint COLLATE utf8mb4_unicode_ci NOT NULL ,
 `join_time` timestamp NULL DEFAULT NULL,
 `join_source`  tinyint COLLATE utf8mb4_unicode_ci DEFAULT NULL,
 `inviter_uid` varchar(64) DEFAULT NULL,
 `operator_uid` varchar(64) DEFAULT NULL,
 PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

CREATE TABLE `group_requests` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `req_id` varchar(64) COLLATE utf8mb4_unicode_ci  NOT NULL ,
  `group_id` varchar(64) COLLATE utf8mb4_unicode_ci  NOT NULL ,
  `req_msg` varchar(255) DEFAULT NULL,
  `req_time` timestamp NULL DEFAULT NULL,
  `join_source`  tinyint COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `inviter_user_id` varchar(64) DEFAULT NULL,
  `handle_user_id` varchar(64) DEFAULT NULL,
  `handle_time` timestamp NULL DEFAULT NULL,
  `handle_result`  tinyint COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;


```

然后运行命令

```shell
goctl model mysql ddl -src="./deploy/sql/social.sql" -dir="./apps/social/socialmodels/" -c
```

将要用到的模型在servicecontext中加载

在服务核心对象中做添加好对应的 model

>   /apps/social/rpc/internal/svc/servicecontext.go

```go
package svc

import (
	"easy-chat/apps/social/rpc/internal/config"
	"easy-chat/apps/social/socialmodels"

	"github.com/zeromicro/go-zero/core/stores/sqlx"
)

type ServiceContext struct {
	Config config.Config

	socialmodels.FriendsModel
	socialmodels.FriendRequestsModel
	socialmodels.GroupsModel
	socialmodels.GroupRequestsModel
	socialmodels.GroupMembersModel
}

func NewServiceContext(c config.Config) *ServiceContext {

	sqlConn := sqlx.NewMysql(c.Mysql.DataSource)

	return &ServiceContext{
		Config:              c,
		FriendsModel:        socialmodels.NewFriendsModel(sqlConn, c.Cache),
		FriendRequestsModel: socialmodels.NewFriendRequestsModel(sqlConn, c.Cache),
		GroupsModel:         socialmodels.NewGroupsModel(sqlConn, c.Cache),
		GroupRequestsModel:  socialmodels.NewGroupRequestsModel(sqlConn, c.Cache),
		GroupMembersModel:   socialmodels.NewGroupMembersModel(sqlConn, c.Cache),
	}
}

```

好友与群业务


好友/群申请

好友/群申请的处理

好友/群成员查询

创群

.......



好友申请

好友申请的时候主要业务为：如果好友存在关联关系则不能继续申请，如果请求已经存在也不能继续申请。

数据库的查询处理

>   /apps/social/rpc/socialmodels/friendrequestsmodel_gen.go

```
func (m *defaultFriendRequestsModel) FindByReqUidAndUserId(ctx context.Context, rid, uid string) (*FriendRequests, error) {
	query := fmt.Sprintf("select %s from %s where `req_uid` = ? and `user_id` = ?", friendRequestsRows, m.table)

	var resp FriendRequests
	err := m.QueryRowNoCacheCtx(ctx, &resp, query, rid, uid)

	switch err {
	case nil:
		return &resp, nil
	case sqlc.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}
```

>   /apps/social/rpc/socialmodels/friendsmodel_gen.go

```go
func (m *defaultFriendsModel) FindByUidAndFid(ctx context.Context, uid, fid string) (*Friends, error) {
	query := fmt.Sprintf("select %s from %s where `user_id` = ? and `friend_uid` = ?", friendsRows, m.table)

	var resp Friends
	err := m.QueryRowNoCacheCtx(ctx, &resp, query, uid, fid)
	switch err {
	case nil:
		return &resp, nil
	case sqlc.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}

func (m *defaultFriendsModel) Inserts(ctx context.Context, session sqlx.Session, data ...*Friends) (sql.Result, error) {
	var (
		sql  strings.Builder
		args []any
	)

	if len(data) == 0 {
		return nil, nil
	}

	// insert into tablename values(数据), (数据)
	sql.WriteString(fmt.Sprintf("insert into %s (%s) values ", m.table, friendsRowsExpectAutoSet))

	for i, v := range data {
		sql.WriteString("(?, ?, ?, ?, ?)")
		args = append(args, v.UserId, v.FriendUid, v.Remark, v.AddSource, v.CreatedAt)
		if i == len(data)-1 {
			break
		}

		sql.WriteString(",")
	}

	return session.ExecCtx(ctx, sql.String(), args...)
}
```

好友申请逻辑

>   /apps/social/rpc/internal/logic/friendputinlogic.go

```go
package logic

import (
	"context"
	"database/sql"
	"time"

	"easy-chat/apps/social/rpc/internal/svc"
	"easy-chat/apps/social/rpc/social"
	"easy-chat/apps/social/socialmodels"
	"easy-chat/pkg/xerr"

	"github.com/pkg/errors"
	"github.com/zeromicro/go-zero/core/logx"
	"easy-chat/pkg/constants"
)

type FriendPutInLogic struct {
	ctx    context.Context
	svcCtx *svc.ServiceContext
	logx.Logger
}

func NewFriendPutInLogic(ctx context.Context, svcCtx *svc.ServiceContext) *FriendPutInLogic {
	return &FriendPutInLogic{
		ctx:    ctx,
		svcCtx: svcCtx,
		Logger: logx.WithContext(ctx),
	}
}

func (l *FriendPutInLogic) FriendPutIn(in *social.FriendPutInReq) (*social.FriendPutInResp, error) {
	// todo: add your logic here and delete this line

	// 申请人是否与目标是好友关系
	friends, err := l.svcCtx.FriendsModel.FindByUidAndFid(l.ctx, in.UserId, in.ReqUid)
	if err != nil && err != socialmodels.ErrNotFound {
		return nil, errors.Wrapf(xerr.NewDBErr(), "find friends by uid and fid err %v req %v ", err, in)
	}
	if friends != nil {
		return &social.FriendPutInResp{}, err
	}

	// 是否已经有过申请，申请是不成功，没有完成
	friendReqs, err := l.svcCtx.FriendRequestsModel.FindByReqUidAndUserId(l.ctx, in.ReqUid, in.UserId)
	if err != nil && err != socialmodels.ErrNotFound {
		return nil, errors.Wrapf(xerr.NewDBErr(), "find friendsRequest by rid and uid err %v req %v ", err, in)
	}
	if friendReqs != nil {
		return &social.FriendPutInResp{}, err
	}

	// 创建申请记录
	_, err = l.svcCtx.FriendRequestsModel.Insert(l.ctx, &socialmodels.FriendRequests{
		UserId: in.UserId,
		ReqUid: in.ReqUid,
		ReqMsg: sql.NullString{
			Valid:  true,
			String: in.ReqMsg,
		},
		ReqTime: time.Unix(in.ReqTime, 0),
		HandleResult: sql.NullInt64{
			Int64: int64(constants.NoHandlerResult),
			Valid: true,
		},
	})

	if err != nil {
		return nil, errors.Wrapf(xerr.NewDBErr(), "insert friendRequest err %v req %v ", err, in)
	}

	return &social.FriendPutInResp{}, nil
}

```

在项目中我们往往会有较多的常量值，而这些常量值往往会在整个项目中都有涉及和应用，故可作为全局，在当前的项目中我们将项目需用到的常量至于 pkg/constants 中。

```
- pkg
  - constants
    - social.go
```

```go
// 处理结果 1. 未处理，2. 处理， 3. 拒绝
type HandlerResult int

const (
	NoHandlerResult     HandlerResult = iota + 1 // 未处理
	PassHandlerResult                            // 通过
	RefuseHandlerResult                          // 拒绝
	CancelHandlerResult
)
```

>   注意：在参数中常量零值需慎重考虑，因为在 go 语言中针对类型往往都会有对应的零值，而这些零值可能恰好会影响到业务，故建议慎重考虑。

### 好友申请处理业务

#### 业务流程分析

好友申请处理业务主要包含以下几个核心功能：

1. **好友申请处理 (FriendPutInHandle)** - 处理好友申请，通过或拒绝
2. **好友申请列表 (FriendPutInList)** - 获取待处理的好友申请列表
3. **好友列表 (FriendList)** - 获取用户的好友列表

#### 数据库表结构

好友关系涉及两张表：

**friends 表 - 好友关系表**
```sql
CREATE TABLE `friends` (
   `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
   `user_id` varchar(64) NOT NULL,        -- 用户ID
   `friend_uid` varchar(64) NOT NULL,     -- 好友ID
   `remark` varchar(255) DEFAULT NULL,    -- 备注名
   `add_source` tinyint DEFAULT NULL,     -- 添加来源
   `created_at` timestamp NULL DEFAULT NULL,
   PRIMARY KEY (`id`)
);
```

**friend_requests 表 - 好友申请表**
```sql
CREATE TABLE `friend_requests` (
   `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
   `user_id` varchar(64) NOT NULL,        -- 被申请人ID
   `req_uid` varchar(64) NOT NULL,        -- 申请人ID
   `req_msg` varchar(255) DEFAULT NULL,   -- 申请消息
   `req_time` timestamp NOT NULL,         -- 申请时间
   `handle_result` tinyint DEFAULT NULL,  -- 处理结果
   `handle_msg` varchar(255) DEFAULT NULL,
   `handled_at` timestamp NULL DEFAULT NULL,
   PRIMARY KEY (`id`)
);
```

#### 处理结果常量定义

> /easy-chat/pkg/constants/social.go

```go
// 处理结果 1. 未处理，2. 通过，3. 拒绝
type HandlerResult int

const (
	NoHandlerResult     HandlerResult = iota + 1 // 未处理
	PassHandlerResult                            // 通过
	RefuseHandlerResult                          // 拒绝
	CancelHandlerResult
)
```

#### 好友申请处理实现

> /easy-chat/apps/social/rpc/internal/logic/friendputinhandlelogic.go

**业务逻辑：**

1. 根据 `friendReqId` 获取好友申请记录
2. 验证申请是否已被处理（已通过/已拒绝则报错）
3. 更新申请处理结果
4. 如果通过，创建双向好友关系记录（事务处理）

```go
func (l *FriendPutInHandleLogic) FriendPutInHandle(in *social.FriendPutInHandleReq) (*social.FriendPutInHandleResp, error) {
	// 获取好友申请记录
	friendReq, err := l.svcCtx.FriendRequestsModel.FindOne(l.ctx, uint64(in.FriendReqId))
	if err != nil {
		return nil, errors.Wrapf(xerr.NewDBErr(), "find friendsRequest by friendReqid err %v req %v ", err, in.FriendReqId)
	}

	// 验证是否有处理
	switch constants.HandlerResult(friendReq.HandleResult.Int64) {
	case constants.PassHandlerResult:
		return nil, errors.WithStack(ErrFriendReqBeforePass)
	case constants.RefuseHandlerResult:
		return nil, errors.WithStack(ErrFriendReqBeforeRefuse)
	}

	friendReq.HandleResult.Int64 = int64(in.HandleResult)

	// 修改申请结果 -》 通过【建立两条好友关系记录】 -》 事务
	err = l.svcCtx.FriendRequestsModel.Trans(l.ctx, func(ctx context.Context, session sqlx.Session) error {
		// 更新申请状态
		if err := l.svcCtx.FriendRequestsModel.Update(l.ctx, session, friendReq); err != nil {
			return errors.Wrapf(xerr.NewDBErr(), "update friend request err %v, req %v", err, friendReq)
		}

		// 如果不是通过，直接返回
		if constants.HandlerResult(in.HandleResult) != constants.PassHandlerResult {
			return nil
		}

		// 创建双向好友关系（A->B 和 B->A）
		friends := []*socialmodels.Friends{
			{UserId: friendReq.UserId, FriendUid: friendReq.ReqUid},
			{UserId: friendReq.ReqUid, FriendUid: friendReq.UserId},
		}

		_, err = l.svcCtx.FriendsModel.Inserts(l.ctx, session, friends...)
		if err != nil {
			return errors.Wrapf(xerr.NewDBErr(), "friends inserts err %v, req %v", err, friends)
		}
		return nil
	})

	return &social.FriendPutInHandleResp{}, err
}
```

**关键点说明：**
- 使用事务确保数据一致性
- 通过好友申请时，需要创建两条好友关系记录（双向关系）
- `handle_result` 字段控制申请状态，`ListNoHandler` 方法查询 `handle_result = 1` 的记录

#### 好友申请列表实现

> /easy-chat/apps/social/rpc/internal/logic/friendputinlistlogic.go

**业务逻辑：** 查询指定用户未处理的好友申请列表

```go
func (l *FriendPutInListLogic) FriendPutInList(in *social.FriendPutInListReq) (*social.FriendPutInListResp, error) {
	friendReqList, err := l.svcCtx.FriendRequestsModel.ListNoHandler(l.ctx, in.UserId)
	if err != nil {
		return nil, errors.Wrapf(xerr.NewDBErr(), "find list friend req err %v req %v", err, in.UserId)
	}

	var resp []*social.FriendRequests
	copier.Copy(&resp, &friendReqList)

	return &social.FriendPutInListResp{List: resp}, nil
}
```

**ListNoHandler 方法实现：**

> /easy-chat/apps/social/socialmodels/friendrequestsmodel_gen.go

```go
func (m *defaultFriendRequestsModel) ListNoHandler(ctx context.Context, userId string) ([]*FriendRequests, error) {
	// 关键：查询 handle_result = 1 (未处理) 的记录
	query := fmt.Sprintf("select %s from %s where `handle_result` = 1 and `user_id` = ?", friendRequestsRows, m.table)
	
	var resp []*FriendRequests
	err := m.QueryRowsNoCacheCtx(ctx, &resp, query, userId)
	// ...
}
```

**设计说明：**
- 只查询 `handle_result = 1` 的记录（未处理）
- 处理后 `handle_result` 变为 2（通过）或 3（拒绝），不再出现在列表中

#### 好友列表实现

> /easy-chat/apps/social/rpc/internal/logic/friendlistlogic.go

```go
func (l *FriendListLogic) FriendList(in *social.FriendListReq) (*social.FriendListResp, error) {
	friendsList, err := l.svcCtx.FriendsModel.ListByUserid(l.ctx, in.UserId)
	if err != nil {
		return nil, errors.Wrapf(xerr.NewDBErr(), "list friend by uid err %v req %v ", err, in.UserId)
	}

	var respList []*social.Friends
	copier.Copy(&respList, &friendsList)

	return &social.FriendListResp{List: respList}, nil
}
```

测

<img src="../../../PHOTOS/image-20260217234907704.png" alt="image-20260217234907704" style="zoom:50%;" />

<img src="../../../PHOTOS/image-20260218000717861.png" alt="image-20260218000717861" style="zoom:50%;" />

<img src="../../../PHOTOS/image-20260218000802165.png" alt="image-20260218000802165" style="zoom:50%;" /><img src="../../../PHOTOS/image-20260218000812156.png" alt="image-20260218000812156" style="zoom:50%;" /><img src="../../../PHOTOS/image-20260218000855694.png" alt="image-20260218000855694" style="zoom:50%;" /><img src="../../../PHOTOS/image-20260218000913555.png" alt="image-20260218000913555" style="zoom:50%;" />



### 群相关业务开发

#### 业务流程分析

群业务主要包含以下核心功能：

1. **创建群 (GroupCreate)** - 创建群组并添加创建者为群主
2. **申请进群 (GroupPutin)** - 用户申请或被邀请加入群
3. **处理进群申请 (GroupPutInHandle)** - 群管理员处理进群申请
4. **进群申请列表 (GroupPutinList)** - 获取群的待处理申请列表
5. **用户群列表 (GroupList)** - 获取用户加入的所有群
6. **群成员列表 (GroupUsers)** - 获取群的所有成员

#### 数据库表结构

群业务涉及三张表：

**groups 表 - 群信息表**
```sql
CREATE TABLE `groups` (
 `id` varchar(24) NOT NULL,              -- 群ID
 `name` varchar(255) NOT NULL,           -- 群名称
 `icon` varchar(255) NOT NULL,           -- 群头像
 `status` tinyint DEFAULT NULL,          -- 群状态
 `creator_uid` varchar(64) NOT NULL,     -- 创建者ID
 `group_type` int(11) NOT NULL,          -- 群类型
 `is_verify` boolean NOT NULL,           -- 是否需要验证
 `notification` varchar(255) DEFAULT NULL, -- 群公告
 `notification_uid` varchar(64) DEFAULT NULL,
 `created_at` timestamp NULL DEFAULT NULL,
 `updated_at` timestamp NULL DEFAULT NULL,
 PRIMARY KEY (`id`)
);
```

**group_members 表 - 群成员表**
```sql
CREATE TABLE `group_members` (
 `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
 `group_id` varchar(64) NOT NULL,        -- 群ID
 `user_id` varchar(64) NOT NULL,         -- 用户ID
 `role_level` tinyint NOT NULL,          -- 角色等级
 `join_time` timestamp NULL DEFAULT NULL,
 `join_source` tinyint DEFAULT NULL,     -- 进群方式
 `inviter_uid` varchar(64) DEFAULT NULL, -- 邀请人ID
 `operator_uid` varchar(64) DEFAULT NULL,
 PRIMARY KEY (`id`)
);
```

**group_requests 表 - 进群申请表**
```sql
CREATE TABLE `group_requests` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `req_id` varchar(64) NOT NULL,         -- 申请人ID
  `group_id` varchar(64) NOT NULL,       -- 群ID
  `req_msg` varchar(255) DEFAULT NULL,   -- 申请消息
  `req_time` timestamp NULL DEFAULT NULL,
  `join_source` tinyint DEFAULT NULL,    -- 进群方式
  `inviter_user_id` varchar(64) DEFAULT NULL, -- 邀请人ID
  `handle_user_id` varchar(64) DEFAULT NULL,  -- 处理人ID
  `handle_time` timestamp NULL DEFAULT NULL,
  `handle_result` tinyint DEFAULT NULL,  -- 处理结果
  PRIMARY KEY (`id`)
);
```

#### 群相关常量定义

> /easy-chat/pkg/constants/social.go

```go
// 群等级 1. 创建者，2. 管理者，3. 普通
type GroupRoleLevel int

const (
	CreatorGroupRoleLevel GroupRoleLevel = iota + 1 // 创建者
	ManagerGroupRoleLevel                           // 管理员
	AtLargeGroupRoleLevel                           // 普通成员
)

// 进群申请的方式： 1. 邀请，2. 申请
type GroupJoinSource int

const (
	InviteGroupJoinSource GroupJoinSource = iota + 1 // 邀请进群
	PutInGroupJoinSource                             // 申请进群
)
```

#### 创建群实现

> /easy-chat/apps/social/rpc/internal/logic/groupcreatelogic.go

**业务逻辑：**

1. 生成群ID
2. 创建群信息记录
3. 将创建者添加为群成员（角色为创建者）

```go
func (l *GroupCreateLogic) GroupCreate(in *social.GroupCreateReq) (*social.GroupCreateResp, error) {
	groups := &socialmodels.Groups{
		Id:         wuid.GenUid(l.svcCtx.Config.Mysql.DataSource),
		Name:       in.Name,
		Icon:       in.Icon,
		CreatorUid: in.CreatorUid,
		IsVerify:   false, // 是否需要验证
	}

	err := l.svcCtx.GroupsModel.Trans(l.ctx, func(ctx context.Context, session sqlx.Session) error {
		// 创建群
		_, err := l.svcCtx.GroupsModel.Insert(l.ctx, session, groups)
		if err != nil {
			return errors.Wrapf(xerr.NewDBErr(), "insert group err %v req %v", err, in)
		}

		// 创建者加入群，角色为创建者
		_, err = l.svcCtx.GroupMembersModel.Insert(l.ctx, session, &socialmodels.GroupMembers{
			GroupId:   groups.Id,
			UserId:    in.CreatorUid,
			RoleLevel: int(constants.CreatorGroupRoleLevel),
		})
		if err != nil {
			return errors.Wrapf(xerr.NewDBErr(), "insert group member err %v req %v", err, in)
		}
		return nil
	})

	return &social.GroupCreateResp{}, err
}
```

**关键点说明：**
- 使用事务确保群创建和成员添加的原子性
- 创建者自动成为群成员，角色等级为 `CreatorGroupRoleLevel`

**改进点**：

1.  IsVerify。

    它表示这个群是否需要审核。

    你现在写死为 false。

    这其实是一个“业务开关”。

    如果未来要支持“入群审核”，这里就会参与后续逻辑判断。



#### 申请进群实现

> /easy-chat/apps/social/rpc/internal/logic/groupputinlogic.go

**业务逻辑：**

进群有三种情况：

1. **普通用户申请** - 如果群无需验证直接进入，否则创建申请记录
2. **群成员邀请** - 如果群无需验证直接进入，否则创建申请记录
3. **群管理员/群创建者邀请** - 直接进入群

```go
func (l *GroupPutinLogic) GroupPutin(in *social.GroupPutinReq) (*social.GroupPutinResp, error) {
	// 1. 检查用户是否已是群成员
	userGroupMember, err := l.svcCtx.GroupMembersModel.FindByGroudIdAndUserId(l.ctx, in.ReqId, in.GroupId)
	if userGroupMember != nil {
		return &social.GroupPutinResp{}, nil // 已是成员
	}

	// 2. 检查是否已有待处理的申请
	groupReq, err := l.svcCtx.GroupRequestsModel.FindByGroupIdAndReqId(l.ctx, in.GroupId, in.ReqId)
	if groupReq != nil {
		return &social.GroupPutinResp{}, nil // 已有申请
	}

	// 3. 获取群信息，判断是否需要验证
	groupInfo, err := l.svcCtx.GroupsModel.FindOne(l.ctx, in.GroupId)
	if !groupInfo.IsVerify {
		// 不需要验证，直接进群
		// 创建申请记录（已通过）+ 创建群成员记录
	}

	// 4. 根据进群方式处理
	if constants.GroupJoinSource(in.JoinSource) == constants.PutInGroupJoinSource {
		// 申请进群，需要等待审核
		return l.createGroupReq(groupReq, false)
	}

	// 5. 邀请进群，检查邀请人权限
	inviteGroupMember, err := l.svcCtx.GroupMembersModel.FindByGroudIdAndUserId(l.ctx, in.InviterUid, in.GroupId)
	if constants.GroupRoleLevel(inviteGroupMember.RoleLevel) == constants.CreatorGroupRoleLevel || 
	   constants.GroupRoleLevel(inviteGroupMember.RoleLevel) == constants.ManagerGroupRoleLevel {
		// 管理员或创建者邀请，直接进群
	}
	
	return l.createGroupReq(groupReq, false)
}
```

**关键点说明：**
- `is_verify` 字段控制是否需要管理员审核
- 邀请人权限决定是否可以直接拉人进群
- 三种角色等级：创建者 > 管理员 > 普通成员

#### 处理进群申请实现

> /easy-chat/apps/social/rpc/internal/logic/groupputinhandlelogic.go

**业务逻辑：**

1. 获取进群申请记录
2. 验证申请是否已被处理
3. 更新申请处理结果
4. 如果通过，创建群成员记录

```go
func (l *GroupPutInHandleLogic) GroupPutInHandle(in *social.GroupPutInHandleReq) (*social.GroupPutInHandleResp, error) {
	// 获取进群申请记录
	groupReq, err := l.svcCtx.GroupRequestsModel.FindOne(l.ctx, int64(in.GroupReqId))
	if err != nil {
		return nil, errors.Wrapf(xerr.NewDBErr(), "find friend req err %v req %v", err, in.GroupReqId)
	}

	// 验证是否已处理
	switch constants.HandlerResult(groupReq.HandleResult.Int64) {
	case constants.PassHandlerResult:
		return nil, errors.WithStack(ErrGroupReqBeforePass)
	case constants.RefuseHandlerResult:
		return nil, errors.WithStack(ErrGroupReqBeforeRefuse)
	}

	groupReq.HandleResult = sql.NullInt64{Int64: int64(in.HandleResult), Valid: true}

	// 事务处理
	err = l.svcCtx.GroupRequestsModel.Trans(l.ctx, func(ctx context.Context, session sqlx.Session) error {
		// 更新申请状态
		if err := l.svcCtx.GroupRequestsModel.Update(l.ctx, session, groupReq); err != nil {
			return errors.Wrapf(xerr.NewDBErr(), "update friend req err %v req %v", err, groupReq)
		}

		// 如果通过，添加群成员
		if constants.HandlerResult(groupReq.HandleResult.Int64) != constants.PassHandlerResult {
			return nil
		}

		groupMember := &socialmodels.GroupMembers{
			GroupId:     groupReq.GroupId,
			UserId:      groupReq.ReqId,
			RoleLevel:   int(constants.AtLargeGroupRoleLevel), // 普通成员
			OperatorUid: in.HandleUid,
		}
		_, err = l.svcCtx.GroupMembersModel.Insert(l.ctx, session, groupMember)
		// ...
	})

	return &social.GroupPutInHandleResp{}, err
}
```

#### 用户群列表实现

> /easy-chat/apps/social/rpc/internal/logic/grouplistlogic.go

**业务逻辑：**

1. 查询用户加入的所有群成员记录
2. 提取群ID列表
3. 批量查询群信息

```go
func (l *GroupListLogic) GroupList(in *social.GroupListReq) (*social.GroupListResp, error) {
	// 1. 查询用户的群成员记录
	userGroup, err := l.svcCtx.GroupMembersModel.ListByUserId(l.ctx, in.UserId)
	if err != nil {
		return nil, errors.Wrapf(xerr.NewDBErr(), "list group member err %v req %v", err, in.UserId)
	}
	if len(userGroup) == 0 {
		return &social.GroupListResp{}, nil
	}

	// 2. 提取群ID
	ids := make([]string, 0, len(userGroup))
	for _, v := range userGroup {
		ids = append(ids, v.GroupId)
	}

	// 3. 批量查询群信息
	groups, err := l.svcCtx.GroupsModel.ListByGroupIds(l.ctx, ids)
	if err != nil {
		return nil, errors.Wrapf(xerr.NewDBErr(), "list group err %v req %v", err, ids)
	}

	var respList []*social.Groups
	copier.Copy(&respList, &groups)

	return &social.GroupListResp{List: respList}, nil
}
```

#### 群成员列表实现

> /easy-chat/apps/social/rpc/internal/logic/groupuserslogic.go

```go
func (l *GroupUsersLogic) GroupUsers(in *social.GroupUsersReq) (*social.GroupUsersResp, error) {
	groupMembers, err := l.svcCtx.GroupMembersModel.ListByGroupId(l.ctx, in.GroupId)
	if err != nil {
		return nil, errors.Wrapf(xerr.NewDBErr(), "list group member err %v req %v", err, in.GroupId)
	}

	var respList []*social.GroupMembers
	copier.Copy(&respList, &groupMembers)

	return &social.GroupUsersResp{List: respList}, nil
}
```

---

总结

好友业务流程图

```
用户A申请添加好友B
       ↓
检查是否已是好友 → 是 → 返回
       ↓ 否
检查是否已有申请 → 是 → 返回
       ↓ 否
创建好友申请记录 (handle_result=1)
       ↓
用户B查看申请列表 (查询 handle_result=1)
       ↓
用户B处理申请 (通过/拒绝)
       ↓
通过 → 创建双向好友关系 + 更新申请状态(handle_result=2)
拒绝 → 更新申请状态(handle_result=3)
```

群业务流程图

```
创建群 → 创建群记录 + 创建者为群成员(role_level=1)
       ↓
用户申请/被邀请进群
       ↓
检查是否已是成员 → 是 → 返回
       ↓ 否
检查群是否需要验证
       ↓
不需要验证 → 直接进群
需要验证 → 创建申请记录
       ↓
管理员查看申请列表
       ↓
管理员处理申请
       ↓
通过 → 创建群成员记录(role_level=3) + 更新申请状态
拒绝 → 更新申请状态
```

关键设计要点

1. **双向好友关系** - 好友关系是双向的，通过申请时需要创建两条记录
2. **事务处理** - 关键操作使用事务确保数据一致性
3. **状态控制** - 使用 `handle_result` 字段控制申请状态，便于查询和管理
4. **权限控制** - 群角色等级控制不同权限（创建者 > 管理员 > 普通成员）
5. **验证机制** - `is_verify` 字段控制群是否需要审核进群申请



social api 测试结果
![image-20260219215149930](../../../PHOTOS/image-20260219215149930.png)

![image-20260219215200766](../../../PHOTOS/image-20260219215200766.png)![image-20260219215207539](../../../PHOTOS/image-20260219215207539.png)![image-20260219215240368](../../../PHOTOS/image-20260219215240368.png)![image-20260219220835581](../../../PHOTOS/image-20260219220835581.png)![image-20260219220851005](../../../PHOTOS/image-20260219220851005.png)



### 发布和部署的流程（这里以user-api服务为例即可）

描述镜像怎么构造

>   apps/deploy/dockerfile/Dockerfile_user_api_dev

```dockerfile
FROM alpine:3.18

# 添加时区处理
RUN echo -e "https://mirrors.aliyun.com/alpine/v3.15/main\nhttps://mirrors.aliyun.com/alpine/v3.15/community" > /etc/apk/repositories && \
    apk update &&\
    apk --no-cache add tzdata && \
    cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime && \
    echo "Asia/Shanghai" >  /etc/timezone
ENV TZ=Asia/Shanghai

ARG SERVER_NAME=user
ARG SERVER_TYPE=api
#一般改这里就行

ENV RUN_BIN bin/${SERVER_NAME}-${SERVER_TYPE}
ENV RUN_CONF /${SERVER_NAME}/conf/${SERVER_NAME}.yaml

# 这个关键词的意思是复制的意思，可以将宿主机中的内容复制到容器中
# 命令 左边是宿主机的目录，右边是容器目录
RUN mkdir /$SERVER_NAME && mkdir /$SERVER_NAME/bin && mkdir /$SERVER_NAME/conf

# 复制编译后的二进制文件
COPY ./bin/$SERVER_NAME-$SERVER_TYPE /$SERVER_NAME/bin/

# 复制配置文件
COPY ./apps/$SERVER_NAME/$SERVER_TYPE/etc/dev/$SERVER_NAME.yaml /$SERVER_NAME/conf/

# 为二进制提供执行权限
RUN chmod +x /$SERVER_NAME/bin/$SERVER_NAME-$SERVER_TYPE

# 该命令指定容器会默认进入那个目录，如我们每次进入服务器的时候会自动进入root目录一样的作用
WORKDIR /$SERVER_NAME

# 这个命令可以让我们的docker容器在启动的时候就执行下面的命令
# 与CMD不同之处是，在docker run 后跟的命令不能替换它，它仍然会启动的时候执行
# ENTRYPOINT ["$RUN_BIN", "-f", "$RUN_CONF"] // 这种写法不支持对环境变量的解析，
#您正在使用ENTRYPOINT 的exec形式。与shell表单不同，exec表单不会调用命令shell。这意味着正常的外壳处理不会发生。例如，ENTRYPOINT [ "echo", "$HOME" ]
# 将不会在$ HOME上进行变量替换。如果要进行shell处理，则可以使用shell形式或直接执行shell，例如：ENTRYPOINT [ "sh", "-c", "echo $HOME" ]。
#当使用exec表单并直接执行shell时（例如在shell表单中），是由shell进行环境变量扩展，而不是docker。（来自Dockerfile参考）
#

ENTRYPOINT $RUN_BIN -f $RUN_CONF

```

发布部署的命令mk

>   apps/deploy/mk/user-api.mk

```mk
VERSION=latest

SERVER_NAME=user
SERVER_TYPE=api
#一般改这里就行

# 测试环境配置
# docker的镜像发布地址
DOCKER_REPO_TEST=crpi-osk929019sdokpya.cn-guangzhou.personal.cr.aliyuncs.com/easy-ct/${SERVER_NAME}-${SERVER_TYPE}-dev
# 测试版本
VERSION_TEST=$(VERSION)
# 编译的程序名称
APP_NAME_TEST=easy-im-${SERVER_NAME}-${SERVER_TYPE}-test

# 测试下的编译文件
DOCKER_FILE_TEST=./deploy/dockerfile/Dockerfile_${SERVER_NAME}_${SERVER_TYPE}_dev

# 测试环境的编译发布
build-test:

	GOOS=linux GOARCH=amd64 CGO_ENABLED=0 go build -o bin/${SERVER_NAME}-${SERVER_TYPE} ./apps/${SERVER_NAME}/${SERVER_TYPE}/${SERVER_NAME}.go
	docker build . -f ${DOCKER_FILE_TEST} --no-cache -t ${APP_NAME_TEST}

# 镜像的测试标签
tag-test:

	@echo 'create tag ${VERSION_TEST}'
	docker tag ${APP_NAME_TEST} ${DOCKER_REPO_TEST}:${VERSION_TEST}

publish-test:

	@echo 'publish ${VERSION_TEST} to ${DOCKER_REPO_TEST}'
	docker push $(DOCKER_REPO_TEST):${VERSION_TEST}

release-test: build-test tag-test publish-test

```

删除现有的镜像再从仓库中拉取最新的镜像

>   apps/deploy/script/userr-api-test.sh

```sh
#!/bin/bash

reso_addr='crpi-osk929019sdokpya.cn-guangzhou.personal.cr.aliyuncs.com/easy-ct/user-api-dev'
tag='latest'

echo "登录阿里云镜像仓库..."
docker login --username=onychen crpi-osk929019sdokpya.cn-guangzhou.personal.cr.aliyuncs.com

pod_ip="192.168.88.130"

container_name="easy-chat-user-api-test"

docker stop ${container_name}

docker rm ${container_name}

docker rmi ${reso_addr}:${tag}

docker pull ${reso_addr}:${tag}


# 如果需要指定配置文件的
# docker run -p 10001:8080 --network imooc_easy-im -v /easy-im/config/user-rpc:/user/conf/ --name=${container_name} -d ${reso_addr}:${tag}
docker run -p 8888:8888 -e POD_IP=${pod_ip}  --name=${container_name} -d ${reso_addr}:${tag}
```

添加到总sh中

>   apps/deploy/script/release-test.sh

```sh
#!/bin/bash

need_start_server_shell=(
    "user-rpc-test.sh"
    "user-api-test.sh"
    ##添加即可
)

for i in ${need_start_server_shell[*]} ; do
    chmod +x $i
    ./$i
done


docker ps

docker exec -it etcd etcdctl get --prefix ""
```

然后把新的发布部署命令添加到大mk中

>   /easy-chat/Makefile

```makefile
user-rpc-dev:
	@make -f deploy/mk/user-rpc.mk release-test

##添加
user-api-dev:
	@make -f deploy/mk/user-api.mk release-test	

##编译推送命令
##添加
release-test: user-rpc-dev user-api-dev 


##拉取命令
install-server:
	cd ./deploy/script && chmod +x release-test.sh && ./release-test.sh
```

然后把代码推到开发机

```
make release-test
```

然后在部署测试机上

```
make install-server
```

即可

### im业务开发

完成服务构建，请求接受，路由，鉴权

<img src="../../../PHOTOS/image-20260223162101642.png" alt="image-20260223162101642" style="zoom:50%;" />

#### 实现im业务和用户登入的连接

要实现 IM 业务与用户登录的连接，核心思路是：当客户端通过 WebSocket 连接到 IM 服务时，需要验证客户端携带的 JWT Token 是否有效，验证通过后将用户 ID 取出并存入上下文中，供后续业务处理使用。

首先需要在配置文件中添加 JWT 相关的配置项。打开 apps/im/ws/etc/dev/im.yaml 文件，在 ListenOn 字段后面添加 JwtAuth 配置：

```yaml
Name: im.ws
ListenOn: 0.0.0.0:8882

JwtAuth:
  AccessSecret: onychen123
```

这个配置定义了 JWT 验签的密钥，需要与用户服务生成 Token 时使用的密钥保持一致。AccessSecret 的值 onychen123 是开发环境使用的密钥。

接下来需要在 config.go 中定义对应的配置结构体。打开 apps/im/ws/internal/config/config.go 文件，添加 JwtAuth 结构体：

```go
type Config struct {
	service.ServiceConf

	ListenOn string

	JwtAuth struct {
		AccessSecret string
	}
}
```

这个结构体定义了配置文件中 JwtAuth 部分的数据结构，AccessSecret 字段用于接收配置文件中的密钥。

然后需要创建 JWT 认证处理器。打开 apps/im/ws/internal/handler/auth.go 文件，实现 JWT 验证逻辑：

```go
package handler

import (
	"context"
	"easy-chat/apps/im/ws/internal/svc"
	"easy-chat/pkg/ctxdata"
	"net/http"

	"github.com/golang-jwt/jwt/v4"
	"github.com/zeromicro/go-zero/core/logx"
	"github.com/zeromicro/go-zero/rest/token"
)

type JwtAuth struct {
	svc    *svc.ServiceContext
	parser *token.TokenParser
	logx.Logger
}

func NewJwtAuth(svc *svc.ServiceContext) *JwtAuth {
	return &JwtAuth{
		svc:    svc,
		parser: token.NewTokenParser(),
		Logger: logx.WithContext(context.Background()),
	}
}

func (j *JwtAuth) Auth(w http.ResponseWriter, r *http.Request) bool {
	tok, err := j.parser.ParseToken(r, j.svc.Config.JwtAuth.AccessSecret, "")
	if err != nil {
		j.Errorf("parse token err %v ", err)
		return false
	}

	if !tok.Valid {
		return false
	}

	claims, ok := tok.Claims.(jwt.MapClaims)
	if !ok {
		return false
	}

	*r = *r.WithContext(context.WithValue(r.Context(), ctxdata.Identify, claims[ctxdata.Identify]))

	return true
}

func (j *JwtAuth) UserId(r *http.Request) string {
	return ctxdata.GetUId(r.Context())
}
```

这个认证处理器实现了两个核心方法：Auth 方法用于验证 Token 的有效性，它调用 go-zero 框架提供的 token.ParseToken 方法进行验签，验证通过后将用户 ID 存入请求的 context 中；UserId 方法用于从请求中获取用户 ID。

接下来需要在 WebSocket 服务启动时注入这个认证处理器。打开 apps/im/ws/im.go 文件，修改 NewServer 的调用：

```go
ctx := svc.NewServiceContext(c)

srv := websocket.NewServer(c.ListenOn,
	websocket.WithServerAuthentication(handler.NewJwtAuth(ctx)),
)
defer srv.Stop()

handler.RegisterHandlers(srv, ctx)
```

这里使用 WithServerAuthentication 选项将自定义的 JwtAuth 处理器注入到 WebSocket 服务器中。当有客户端连接时，服务器会先调用 JwtAuth 的 Auth 方法进行验证。

WebSocket 服务器在处理连接时会调用认证逻辑。打开 apps/im/ws/websocket/server.go 文件中的 ServerWs 方法可以看到认证流程：

```go
func (s *Server) ServerWs(w http.ResponseWriter, r *http.Request) {
	conn, err := s.upgrader.Upgrade(w, r, nil)
	if err != nil {
		s.Error("upgrade http conn err", err)
		return
	}

	if !s.authentication.Auth(w, r) {
		conn.WriteMessage(websocket.TextMessage, []byte("auth err"))
		conn.Close()
		return
	}
	// 添加连接记录
	s.addConn(conn, r)
	// 读取信息，完成请求
	go s.handlerConn(conn)
}
```

当客户端发起 WebSocket 连接请求时，服务器会先调用 authentication.Auth 方法进行 JWT Token 验证。如果验证失败，会向客户端发送认证错误消息并关闭连接；如果验证成功，则将连接添加到连接池中，并启动协程处理后续的消息收发。

最后需要在路由注册中定义业务处理 handler。打开 apps/im/ws/internal/handler/router.go 文件：

```go
package handler

import (
	"easy-chat/apps/im/ws/internal/handler/user"
	"easy-chat/apps/im/ws/internal/svc"
	"easy-chat/apps/im/ws/websocket"
)

func RegisterHandlers(srv *websocket.Server, svc *svc.ServiceContext) {
	srv.AddRoutes([]websocket.Route{
		{
			Method:  "user.online",
			Handler: user.OnLine(svc),
		},
	})
}
```

这里注册了一个 user.online 方法，当客户端发送包含这个方法的 WebSocket 消息时，会调用 user.OnLine 处理函数进行处理。

业务 handler 的实现可以参考 apps/im/ws/internal/handler/user/user.go 文件：

```go
package user

import (
	"easy-chat/apps/im/ws/internal/svc"
	websocketx "easy-chat/apps/im/ws/websocket"

	"github.com/gorilla/websocket"
)

func OnLine(svc *svc.ServiceContext) websocketx.HandlerFunc {
	return func(srv *websocketx.Server, conn *websocket.Conn, msg *websocketx.Message) {
		uids := srv.GetUsers()
		u := srv.GetUsers(conn)
		if len(u) == 0 {
			srv.Error("there is no user")
			return
		}
		err := srv.Send(websocketx.NewMessage(u[0], uids), conn)
		srv.Info("err ", err)
	}
}
```

这个 handler 展示了如何获取当前连接的用户 ID，以及如何向客户端发送消息。

整个连接流程如下：用户首先通过用户服务登录获取 JWT Token，然后携带这个 Token 连接到 WebSocket 服务；WebSocket 服务在建立连接时调用 JWT 认证中间件验证 Token 有效性；认证通过后将用户 ID 存入上下文，后续业务处理就可以通过用户 ID 进行消息收发、好友关系验证等操作。

### 实现im服务心跳检测
